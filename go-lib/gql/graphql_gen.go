// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"time"

	"bitbucket.org/cerealia/apps/go-lib/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AccessApproval() AccessApprovalResolver
	ApproveReq() ApproveReqResolver
	Doc() DocResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Query() QueryResolver
	StageModerator() StageModeratorResolver
	Trade() TradeResolver
	TradeOffer() TradeOfferResolver
	TradeStageAddReq() TradeStageAddReqResolver
	TradeStageDoc() TradeStageDocResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AccessApproval struct {
		Approver  func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Reason    func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	AdminUser struct {
		Approvals func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ApproveReq struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		ApprovedTx   func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqActor     func(childComplexity int) int
		ReqAt        func(childComplexity int) int
		ReqBy        func(childComplexity int) int
		ReqReason    func(childComplexity int) int
		ReqTx        func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	AuthUser struct {
		ID    func(childComplexity int) int
		Token func(childComplexity int) int
	}

	Doc struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Hash      func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Note      func(childComplexity int) int
		Type      func(childComplexity int) int
		URL       func(childComplexity int) int
	}

	Mutation struct {
		AdminApproveUser          func(childComplexity int, id string, status model.SimpleApproval, reason *string) int
		MkTradeCloseTx            func(childComplexity int, id string, operationType model.Approval) int
		MkTradeStageAddTx         func(childComplexity int, id model.TradeStagePath, operationType model.Approval) int
		MkTradeStageCloseTx       func(childComplexity int, id model.TradeStagePath, operationType model.Approval) int
		MkTradeStageDocTx         func(childComplexity int, id model.TradeStageDocPath, operationType model.Approval, expiresAt *time.Time) int
		NotificationDismiss       func(childComplexity int, id string) int
		OrganizationCreate        func(childComplexity int, input model.OrgInput) int
		TradeCloseReq             func(childComplexity int, id string, reason string, signedTx string) int
		TradeCloseReqApprove      func(childComplexity int, id string, signedTx string) int
		TradeCloseReqReject       func(childComplexity int, id string, reason string, signedTx string) int
		TradeCreate               func(childComplexity int, input model.NewTradeInput) int
		TradeOfferClose           func(childComplexity int, id string) int
		TradeOfferCreate          func(childComplexity int, input model.TradeOfferInput) int
		TradeStageAddReq          func(childComplexity int, input model.NewStageInput, signedTx string, withApproval bool) int
		TradeStageAddReqApprove   func(childComplexity int, id model.TradeStagePath, signedTx string) int
		TradeStageAddReqReject    func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageCloseReq        func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageCloseReqApprove func(childComplexity int, id model.TradeStagePath, signedTx string) int
		TradeStageCloseReqReject  func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageDelReq          func(childComplexity int, id model.TradeStagePath, reason string) int
		TradeStageDelReqApprove   func(childComplexity int, id model.TradeStagePath) int
		TradeStageDelReqReject    func(childComplexity int, id model.TradeStagePath, reason string) int
		TradeStageDocApprove      func(childComplexity int, id model.TradeStageDocPath, signedTx string) int
		TradeStageDocReject       func(childComplexity int, id model.TradeStageDocPath, signedTx string, reason string) int
		TradeStageSetExpireTime   func(childComplexity int, id model.TradeStagePath, expiresAt string) int
		UserEmailChange           func(childComplexity int, input []string) int
		UserLogin                 func(childComplexity int, input model.UserLoginInput) int
		UserPasswordChange        func(childComplexity int, input model.ChangePasswordInput) int
		UserProfileUpdate         func(childComplexity int, input model.UserProfileInput) int
		UserSignup                func(childComplexity int, input *model.NewUserInput) int
	}

	Notification struct {
		Action      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Dismissed   func(childComplexity int) int
		EntityID    func(childComplexity int) int
		ID          func(childComplexity int) int
		Msg         func(childComplexity int) int
		Receiver    func(childComplexity int) int
		TriggeredBy func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Organization struct {
		Address   func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Telephone func(childComplexity int) int
	}

	Query struct {
		AdminTrades        func(childComplexity int) int
		AdminUsers         func(childComplexity int) int
		Notifications      func(childComplexity int, from uint) int
		NotificationsTrade func(childComplexity int, id string) int
		Organizations      func(childComplexity int) int
		StellarNet         func(childComplexity int) int
		Trade              func(childComplexity int, id string) int
		TradeOffer         func(childComplexity int, id string) int
		TradeOffers        func(childComplexity int) int
		TradeTemplates     func(childComplexity int) int
		Trades             func(childComplexity int) int
		User               func(childComplexity int, id *string) int
		Users              func(childComplexity int) int
	}

	StageModerator struct {
		CreatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	StellarNet struct {
		Name       func(childComplexity int) int
		Passphrase func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	Trade struct {
		ActorWallet  func(childComplexity int) int
		Buyer        func(childComplexity int) int
		CloseReqs    func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Moderating   func(childComplexity int) int
		Name         func(childComplexity int) int
		ScAddr       func(childComplexity int) int
		Seller       func(childComplexity int) int
		StageAddReqs func(childComplexity int) int
		Stages       func(childComplexity int) int
		Template     func(childComplexity int) int
		TradeOffer   func(childComplexity int) int
	}

	TradeActorWallet struct {
		KeyPath  func(childComplexity int) int
		PubKey   func(childComplexity int) int
		WalletID func(childComplexity int) int
	}

	TradeOffer struct {
		ClosedAt    func(childComplexity int) int
		ComType     func(childComplexity int) int
		Commodity   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Currency    func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Incoterm    func(childComplexity int) int
		IsAnonymous func(childComplexity int) int
		IsSell      func(childComplexity int) int
		MarketLoc   func(childComplexity int) int
		Note        func(childComplexity int) int
		Org         func(childComplexity int) int
		Origin      func(childComplexity int) int
		Price       func(childComplexity int) int
		PriceType   func(childComplexity int) int
		Quality     func(childComplexity int) int
		Shipment    func(childComplexity int) int
		Terms       func(childComplexity int) int
		Vol         func(childComplexity int) int
	}

	TradeStage struct {
		AddReqIdx   func(childComplexity int) int
		CloseReqs   func(childComplexity int) int
		DelReqs     func(childComplexity int) int
		Description func(childComplexity int) int
		Docs        func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		Moderator   func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
	}

	TradeStageAddReq struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		Description  func(childComplexity int) int
		Name         func(childComplexity int) int
		Owner        func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqActor     func(childComplexity int) int
		ReqAt        func(childComplexity int) int
		ReqBy        func(childComplexity int) int
		ReqReason    func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	TradeStageDoc struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		ApprovedTx   func(childComplexity int) int
		Doc          func(childComplexity int) int
		ExpiresAt    func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqTx        func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	TradeStageTemplate struct {
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
	}

	TradeTemplate struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Stages      func(childComplexity int) int
	}

	User struct {
		Avatar    func(childComplexity int) int
		Biography func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Emails    func(childComplexity int) int
		FirstName func(childComplexity int) int
		ID        func(childComplexity int) int
		LastName  func(childComplexity int) int
		OrgMap    func(childComplexity int) int
		PubKey    func(childComplexity int) int
		Roles     func(childComplexity int) int
	}

	UserOrgMap struct {
		Org  func(childComplexity int) int
		Role func(childComplexity int) int
	}
}

type AccessApprovalResolver interface {
	Approver(ctx context.Context, obj *model.AccessApproval) (*model.User, error)
}
type ApproveReqResolver interface {
	ReqBy(ctx context.Context, obj *model.ApproveReq) (*model.User, error)

	ApprovedBy(ctx context.Context, obj *model.ApproveReq) (*model.User, error)
}
type DocResolver interface {
	CreatedBy(ctx context.Context, obj *model.Doc) (*model.User, error)
}
type MutationResolver interface {
	UserSignup(ctx context.Context, input *model.NewUserInput) (*int, error)
	UserLogin(ctx context.Context, input model.UserLoginInput) (*model.AuthUser, error)
	UserPasswordChange(ctx context.Context, input model.ChangePasswordInput) (*int, error)
	UserEmailChange(ctx context.Context, input []string) (*int, error)
	UserProfileUpdate(ctx context.Context, input model.UserProfileInput) (*model.User, error)
	OrganizationCreate(ctx context.Context, input model.OrgInput) (*model.Organization, error)
	TradeCreate(ctx context.Context, input model.NewTradeInput) (*model.Trade, error)
	TradeStageAddReq(ctx context.Context, input model.NewStageInput, signedTx string, withApproval bool) (*model.TradeStageAddReq, error)
	TradeStageAddReqApprove(ctx context.Context, id model.TradeStagePath, signedTx string) (*model.TradeStage, error)
	TradeStageAddReqReject(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*int, error)
	TradeStageDelReq(ctx context.Context, id model.TradeStagePath, reason string) (*model.ApproveReq, error)
	TradeStageDelReqApprove(ctx context.Context, id model.TradeStagePath) (*model.ApproveReq, error)
	TradeStageDelReqReject(ctx context.Context, id model.TradeStagePath, reason string) (*int, error)
	TradeStageCloseReq(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*model.ApproveReq, error)
	TradeStageCloseReqApprove(ctx context.Context, id model.TradeStagePath, signedTx string) (*model.ApproveReq, error)
	TradeStageCloseReqReject(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*int, error)
	TradeStageSetExpireTime(ctx context.Context, id model.TradeStagePath, expiresAt string) (*int, error)
	TradeCloseReq(ctx context.Context, id string, reason string, signedTx string) (*model.ApproveReq, error)
	TradeCloseReqApprove(ctx context.Context, id string, signedTx string) (*model.ApproveReq, error)
	TradeCloseReqReject(ctx context.Context, id string, reason string, signedTx string) (*int, error)
	TradeStageDocApprove(ctx context.Context, id model.TradeStageDocPath, signedTx string) (*model.TradeStageDoc, error)
	TradeStageDocReject(ctx context.Context, id model.TradeStageDocPath, signedTx string, reason string) (*int, error)
	TradeOfferCreate(ctx context.Context, input model.TradeOfferInput) (*model.TradeOffer, error)
	TradeOfferClose(ctx context.Context, id string) (*int, error)
	NotificationDismiss(ctx context.Context, id string) (*int, error)
	MkTradeStageDocTx(ctx context.Context, id model.TradeStageDocPath, operationType model.Approval, expiresAt *time.Time) (string, error)
	MkTradeStageCloseTx(ctx context.Context, id model.TradeStagePath, operationType model.Approval) (string, error)
	MkTradeStageAddTx(ctx context.Context, id model.TradeStagePath, operationType model.Approval) (string, error)
	MkTradeCloseTx(ctx context.Context, id string, operationType model.Approval) (string, error)
	AdminApproveUser(ctx context.Context, id string, status model.SimpleApproval, reason *string) (*model.AccessApproval, error)
}
type NotificationResolver interface {
	TriggeredBy(ctx context.Context, obj *model.Notification) (*model.User, error)
}
type QueryResolver interface {
	User(ctx context.Context, id *string) (*model.User, error)
	Users(ctx context.Context) ([]model.User, error)
	Organizations(ctx context.Context) ([]model.Organization, error)
	AdminUsers(ctx context.Context) ([]model.AdminUser, error)
	TradeTemplates(ctx context.Context) ([]model.TradeTemplate, error)
	Trade(ctx context.Context, id string) (*model.Trade, error)
	Trades(ctx context.Context) ([]model.Trade, error)
	TradeOffer(ctx context.Context, id string) (*model.TradeOffer, error)
	TradeOffers(ctx context.Context) ([]model.TradeOffer, error)
	Notifications(ctx context.Context, from uint) ([]model.Notification, error)
	NotificationsTrade(ctx context.Context, id string) ([]model.Notification, error)
	StellarNet(ctx context.Context) (*model.StellarNet, error)
	AdminTrades(ctx context.Context) ([]model.Trade, error)
}
type StageModeratorResolver interface {
	User(ctx context.Context, obj *model.StageModerator) (*model.User, error)
}
type TradeResolver interface {
	Template(ctx context.Context, obj *model.Trade) (*model.TradeTemplate, error)
	Buyer(ctx context.Context, obj *model.Trade) (*model.User, error)
	Seller(ctx context.Context, obj *model.Trade) (*model.User, error)
	ScAddr(ctx context.Context, obj *model.Trade) (string, error)

	CreatedBy(ctx context.Context, obj *model.Trade) (*model.User, error)

	TradeOffer(ctx context.Context, obj *model.Trade) (*model.TradeOffer, error)

	ActorWallet(ctx context.Context, obj *model.Trade) (*model.TradeActorWallet, error)
}
type TradeOfferResolver interface {
	CreatedBy(ctx context.Context, obj *model.TradeOffer) (*model.User, error)

	Org(ctx context.Context, obj *model.TradeOffer) (*model.Organization, error)

	Terms(ctx context.Context, obj *model.TradeOffer) (*model.Doc, error)
}
type TradeStageAddReqResolver interface {
	ReqBy(ctx context.Context, obj *model.TradeStageAddReq) (*model.User, error)

	ApprovedBy(ctx context.Context, obj *model.TradeStageAddReq) (*model.User, error)
}
type TradeStageDocResolver interface {
	Doc(ctx context.Context, obj *model.TradeStageDoc) (*model.Doc, error)

	ApprovedBy(ctx context.Context, obj *model.TradeStageDoc) (*model.User, error)
}
type UserResolver interface {
	OrgMap(ctx context.Context, obj *model.User) ([]model.UserOrgMap, error)

	PubKey(ctx context.Context, obj *model.User) (*string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AccessApproval.Approver":
		if e.complexity.AccessApproval.Approver == nil {
			break
		}

		return e.complexity.AccessApproval.Approver(childComplexity), true

	case "AccessApproval.CreatedAt":
		if e.complexity.AccessApproval.CreatedAt == nil {
			break
		}

		return e.complexity.AccessApproval.CreatedAt(childComplexity), true

	case "AccessApproval.Reason":
		if e.complexity.AccessApproval.Reason == nil {
			break
		}

		return e.complexity.AccessApproval.Reason(childComplexity), true

	case "AccessApproval.Status":
		if e.complexity.AccessApproval.Status == nil {
			break
		}

		return e.complexity.AccessApproval.Status(childComplexity), true

	case "AdminUser.Approvals":
		if e.complexity.AdminUser.Approvals == nil {
			break
		}

		return e.complexity.AdminUser.Approvals(childComplexity), true

	case "AdminUser.User":
		if e.complexity.AdminUser.User == nil {
			break
		}

		return e.complexity.AdminUser.User(childComplexity), true

	case "ApproveReq.ApprovedAt":
		if e.complexity.ApproveReq.ApprovedAt == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedAt(childComplexity), true

	case "ApproveReq.ApprovedBy":
		if e.complexity.ApproveReq.ApprovedBy == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedBy(childComplexity), true

	case "ApproveReq.ApprovedTx":
		if e.complexity.ApproveReq.ApprovedTx == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedTx(childComplexity), true

	case "ApproveReq.RejectReason":
		if e.complexity.ApproveReq.RejectReason == nil {
			break
		}

		return e.complexity.ApproveReq.RejectReason(childComplexity), true

	case "ApproveReq.ReqActor":
		if e.complexity.ApproveReq.ReqActor == nil {
			break
		}

		return e.complexity.ApproveReq.ReqActor(childComplexity), true

	case "ApproveReq.ReqAt":
		if e.complexity.ApproveReq.ReqAt == nil {
			break
		}

		return e.complexity.ApproveReq.ReqAt(childComplexity), true

	case "ApproveReq.ReqBy":
		if e.complexity.ApproveReq.ReqBy == nil {
			break
		}

		return e.complexity.ApproveReq.ReqBy(childComplexity), true

	case "ApproveReq.ReqReason":
		if e.complexity.ApproveReq.ReqReason == nil {
			break
		}

		return e.complexity.ApproveReq.ReqReason(childComplexity), true

	case "ApproveReq.ReqTx":
		if e.complexity.ApproveReq.ReqTx == nil {
			break
		}

		return e.complexity.ApproveReq.ReqTx(childComplexity), true

	case "ApproveReq.Status":
		if e.complexity.ApproveReq.Status == nil {
			break
		}

		return e.complexity.ApproveReq.Status(childComplexity), true

	case "AuthUser.ID":
		if e.complexity.AuthUser.ID == nil {
			break
		}

		return e.complexity.AuthUser.ID(childComplexity), true

	case "AuthUser.Token":
		if e.complexity.AuthUser.Token == nil {
			break
		}

		return e.complexity.AuthUser.Token(childComplexity), true

	case "Doc.CreatedAt":
		if e.complexity.Doc.CreatedAt == nil {
			break
		}

		return e.complexity.Doc.CreatedAt(childComplexity), true

	case "Doc.CreatedBy":
		if e.complexity.Doc.CreatedBy == nil {
			break
		}

		return e.complexity.Doc.CreatedBy(childComplexity), true

	case "Doc.Hash":
		if e.complexity.Doc.Hash == nil {
			break
		}

		return e.complexity.Doc.Hash(childComplexity), true

	case "Doc.ID":
		if e.complexity.Doc.ID == nil {
			break
		}

		return e.complexity.Doc.ID(childComplexity), true

	case "Doc.Name":
		if e.complexity.Doc.Name == nil {
			break
		}

		return e.complexity.Doc.Name(childComplexity), true

	case "Doc.Note":
		if e.complexity.Doc.Note == nil {
			break
		}

		return e.complexity.Doc.Note(childComplexity), true

	case "Doc.Type":
		if e.complexity.Doc.Type == nil {
			break
		}

		return e.complexity.Doc.Type(childComplexity), true

	case "Doc.URL":
		if e.complexity.Doc.URL == nil {
			break
		}

		return e.complexity.Doc.URL(childComplexity), true

	case "Mutation.AdminApproveUser":
		if e.complexity.Mutation.AdminApproveUser == nil {
			break
		}

		args, err := ec.field_Mutation_adminApproveUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminApproveUser(childComplexity, args["id"].(string), args["status"].(model.SimpleApproval), args["reason"].(*string)), true

	case "Mutation.MkTradeCloseTx":
		if e.complexity.Mutation.MkTradeCloseTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeCloseTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeCloseTx(childComplexity, args["id"].(string), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageAddTx":
		if e.complexity.Mutation.MkTradeStageAddTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageAddTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageAddTx(childComplexity, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageCloseTx":
		if e.complexity.Mutation.MkTradeStageCloseTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageCloseTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageCloseTx(childComplexity, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageDocTx":
		if e.complexity.Mutation.MkTradeStageDocTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageDocTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageDocTx(childComplexity, args["id"].(model.TradeStageDocPath), args["operationType"].(model.Approval), args["expiresAt"].(*time.Time)), true

	case "Mutation.NotificationDismiss":
		if e.complexity.Mutation.NotificationDismiss == nil {
			break
		}

		args, err := ec.field_Mutation_notificationDismiss_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NotificationDismiss(childComplexity, args["id"].(string)), true

	case "Mutation.OrganizationCreate":
		if e.complexity.Mutation.OrganizationCreate == nil {
			break
		}

		args, err := ec.field_Mutation_organizationCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OrganizationCreate(childComplexity, args["input"].(model.OrgInput)), true

	case "Mutation.TradeCloseReq":
		if e.complexity.Mutation.TradeCloseReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReq(childComplexity, args["id"].(string), args["reason"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCloseReqApprove":
		if e.complexity.Mutation.TradeCloseReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReqApprove(childComplexity, args["id"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCloseReqReject":
		if e.complexity.Mutation.TradeCloseReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReqReject(childComplexity, args["id"].(string), args["reason"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCreate":
		if e.complexity.Mutation.TradeCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCreate(childComplexity, args["input"].(model.NewTradeInput)), true

	case "Mutation.TradeOfferClose":
		if e.complexity.Mutation.TradeOfferClose == nil {
			break
		}

		args, err := ec.field_Mutation_tradeOfferClose_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeOfferClose(childComplexity, args["id"].(string)), true

	case "Mutation.TradeOfferCreate":
		if e.complexity.Mutation.TradeOfferCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tradeOfferCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeOfferCreate(childComplexity, args["input"].(model.TradeOfferInput)), true

	case "Mutation.TradeStageAddReq":
		if e.complexity.Mutation.TradeStageAddReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReq(childComplexity, args["input"].(model.NewStageInput), args["signedTx"].(string), args["withApproval"].(bool)), true

	case "Mutation.TradeStageAddReqApprove":
		if e.complexity.Mutation.TradeStageAddReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReqApprove(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string)), true

	case "Mutation.TradeStageAddReqReject":
		if e.complexity.Mutation.TradeStageAddReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReqReject(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageCloseReq":
		if e.complexity.Mutation.TradeStageCloseReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReq(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageCloseReqApprove":
		if e.complexity.Mutation.TradeStageCloseReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReqApprove(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string)), true

	case "Mutation.TradeStageCloseReqReject":
		if e.complexity.Mutation.TradeStageCloseReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReqReject(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageDelReq":
		if e.complexity.Mutation.TradeStageDelReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReq(childComplexity, args["id"].(model.TradeStagePath), args["reason"].(string)), true

	case "Mutation.TradeStageDelReqApprove":
		if e.complexity.Mutation.TradeStageDelReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReqApprove(childComplexity, args["id"].(model.TradeStagePath)), true

	case "Mutation.TradeStageDelReqReject":
		if e.complexity.Mutation.TradeStageDelReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReqReject(childComplexity, args["id"].(model.TradeStagePath), args["reason"].(string)), true

	case "Mutation.TradeStageDocApprove":
		if e.complexity.Mutation.TradeStageDocApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDocApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDocApprove(childComplexity, args["id"].(model.TradeStageDocPath), args["signedTx"].(string)), true

	case "Mutation.TradeStageDocReject":
		if e.complexity.Mutation.TradeStageDocReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDocReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDocReject(childComplexity, args["id"].(model.TradeStageDocPath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageSetExpireTime":
		if e.complexity.Mutation.TradeStageSetExpireTime == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageSetExpireTime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageSetExpireTime(childComplexity, args["id"].(model.TradeStagePath), args["expiresAt"].(string)), true

	case "Mutation.UserEmailChange":
		if e.complexity.Mutation.UserEmailChange == nil {
			break
		}

		args, err := ec.field_Mutation_userEmailChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserEmailChange(childComplexity, args["input"].([]string)), true

	case "Mutation.UserLogin":
		if e.complexity.Mutation.UserLogin == nil {
			break
		}

		args, err := ec.field_Mutation_userLogin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserLogin(childComplexity, args["input"].(model.UserLoginInput)), true

	case "Mutation.UserPasswordChange":
		if e.complexity.Mutation.UserPasswordChange == nil {
			break
		}

		args, err := ec.field_Mutation_userPasswordChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserPasswordChange(childComplexity, args["input"].(model.ChangePasswordInput)), true

	case "Mutation.UserProfileUpdate":
		if e.complexity.Mutation.UserProfileUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_userProfileUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserProfileUpdate(childComplexity, args["input"].(model.UserProfileInput)), true

	case "Mutation.UserSignup":
		if e.complexity.Mutation.UserSignup == nil {
			break
		}

		args, err := ec.field_Mutation_userSignup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserSignup(childComplexity, args["input"].(*model.NewUserInput)), true

	case "Notification.Action":
		if e.complexity.Notification.Action == nil {
			break
		}

		return e.complexity.Notification.Action(childComplexity), true

	case "Notification.CreatedAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.Dismissed":
		if e.complexity.Notification.Dismissed == nil {
			break
		}

		return e.complexity.Notification.Dismissed(childComplexity), true

	case "Notification.EntityID":
		if e.complexity.Notification.EntityID == nil {
			break
		}

		return e.complexity.Notification.EntityID(childComplexity), true

	case "Notification.ID":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.Msg":
		if e.complexity.Notification.Msg == nil {
			break
		}

		return e.complexity.Notification.Msg(childComplexity), true

	case "Notification.Receiver":
		if e.complexity.Notification.Receiver == nil {
			break
		}

		return e.complexity.Notification.Receiver(childComplexity), true

	case "Notification.TriggeredBy":
		if e.complexity.Notification.TriggeredBy == nil {
			break
		}

		return e.complexity.Notification.TriggeredBy(childComplexity), true

	case "Notification.Type":
		if e.complexity.Notification.Type == nil {
			break
		}

		return e.complexity.Notification.Type(childComplexity), true

	case "Organization.Address":
		if e.complexity.Organization.Address == nil {
			break
		}

		return e.complexity.Organization.Address(childComplexity), true

	case "Organization.Email":
		if e.complexity.Organization.Email == nil {
			break
		}

		return e.complexity.Organization.Email(childComplexity), true

	case "Organization.ID":
		if e.complexity.Organization.ID == nil {
			break
		}

		return e.complexity.Organization.ID(childComplexity), true

	case "Organization.Name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.Telephone":
		if e.complexity.Organization.Telephone == nil {
			break
		}

		return e.complexity.Organization.Telephone(childComplexity), true

	case "Query.AdminTrades":
		if e.complexity.Query.AdminTrades == nil {
			break
		}

		return e.complexity.Query.AdminTrades(childComplexity), true

	case "Query.AdminUsers":
		if e.complexity.Query.AdminUsers == nil {
			break
		}

		return e.complexity.Query.AdminUsers(childComplexity), true

	case "Query.Notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["from"].(uint)), true

	case "Query.NotificationsTrade":
		if e.complexity.Query.NotificationsTrade == nil {
			break
		}

		args, err := ec.field_Query_notificationsTrade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NotificationsTrade(childComplexity, args["id"].(string)), true

	case "Query.Organizations":
		if e.complexity.Query.Organizations == nil {
			break
		}

		return e.complexity.Query.Organizations(childComplexity), true

	case "Query.StellarNet":
		if e.complexity.Query.StellarNet == nil {
			break
		}

		return e.complexity.Query.StellarNet(childComplexity), true

	case "Query.Trade":
		if e.complexity.Query.Trade == nil {
			break
		}

		args, err := ec.field_Query_trade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trade(childComplexity, args["id"].(string)), true

	case "Query.TradeOffer":
		if e.complexity.Query.TradeOffer == nil {
			break
		}

		args, err := ec.field_Query_tradeOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TradeOffer(childComplexity, args["id"].(string)), true

	case "Query.TradeOffers":
		if e.complexity.Query.TradeOffers == nil {
			break
		}

		return e.complexity.Query.TradeOffers(childComplexity), true

	case "Query.TradeTemplates":
		if e.complexity.Query.TradeTemplates == nil {
			break
		}

		return e.complexity.Query.TradeTemplates(childComplexity), true

	case "Query.Trades":
		if e.complexity.Query.Trades == nil {
			break
		}

		return e.complexity.Query.Trades(childComplexity), true

	case "Query.User":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(*string)), true

	case "Query.Users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "StageModerator.CreatedAt":
		if e.complexity.StageModerator.CreatedAt == nil {
			break
		}

		return e.complexity.StageModerator.CreatedAt(childComplexity), true

	case "StageModerator.User":
		if e.complexity.StageModerator.User == nil {
			break
		}

		return e.complexity.StageModerator.User(childComplexity), true

	case "StellarNet.Name":
		if e.complexity.StellarNet.Name == nil {
			break
		}

		return e.complexity.StellarNet.Name(childComplexity), true

	case "StellarNet.Passphrase":
		if e.complexity.StellarNet.Passphrase == nil {
			break
		}

		return e.complexity.StellarNet.Passphrase(childComplexity), true

	case "StellarNet.URL":
		if e.complexity.StellarNet.URL == nil {
			break
		}

		return e.complexity.StellarNet.URL(childComplexity), true

	case "Trade.ActorWallet":
		if e.complexity.Trade.ActorWallet == nil {
			break
		}

		return e.complexity.Trade.ActorWallet(childComplexity), true

	case "Trade.Buyer":
		if e.complexity.Trade.Buyer == nil {
			break
		}

		return e.complexity.Trade.Buyer(childComplexity), true

	case "Trade.CloseReqs":
		if e.complexity.Trade.CloseReqs == nil {
			break
		}

		return e.complexity.Trade.CloseReqs(childComplexity), true

	case "Trade.CreatedAt":
		if e.complexity.Trade.CreatedAt == nil {
			break
		}

		return e.complexity.Trade.CreatedAt(childComplexity), true

	case "Trade.CreatedBy":
		if e.complexity.Trade.CreatedBy == nil {
			break
		}

		return e.complexity.Trade.CreatedBy(childComplexity), true

	case "Trade.Description":
		if e.complexity.Trade.Description == nil {
			break
		}

		return e.complexity.Trade.Description(childComplexity), true

	case "Trade.ID":
		if e.complexity.Trade.ID == nil {
			break
		}

		return e.complexity.Trade.ID(childComplexity), true

	case "Trade.Moderating":
		if e.complexity.Trade.Moderating == nil {
			break
		}

		return e.complexity.Trade.Moderating(childComplexity), true

	case "Trade.Name":
		if e.complexity.Trade.Name == nil {
			break
		}

		return e.complexity.Trade.Name(childComplexity), true

	case "Trade.ScAddr":
		if e.complexity.Trade.ScAddr == nil {
			break
		}

		return e.complexity.Trade.ScAddr(childComplexity), true

	case "Trade.Seller":
		if e.complexity.Trade.Seller == nil {
			break
		}

		return e.complexity.Trade.Seller(childComplexity), true

	case "Trade.StageAddReqs":
		if e.complexity.Trade.StageAddReqs == nil {
			break
		}

		return e.complexity.Trade.StageAddReqs(childComplexity), true

	case "Trade.Stages":
		if e.complexity.Trade.Stages == nil {
			break
		}

		return e.complexity.Trade.Stages(childComplexity), true

	case "Trade.Template":
		if e.complexity.Trade.Template == nil {
			break
		}

		return e.complexity.Trade.Template(childComplexity), true

	case "Trade.TradeOffer":
		if e.complexity.Trade.TradeOffer == nil {
			break
		}

		return e.complexity.Trade.TradeOffer(childComplexity), true

	case "TradeActorWallet.KeyPath":
		if e.complexity.TradeActorWallet.KeyPath == nil {
			break
		}

		return e.complexity.TradeActorWallet.KeyPath(childComplexity), true

	case "TradeActorWallet.PubKey":
		if e.complexity.TradeActorWallet.PubKey == nil {
			break
		}

		return e.complexity.TradeActorWallet.PubKey(childComplexity), true

	case "TradeActorWallet.WalletID":
		if e.complexity.TradeActorWallet.WalletID == nil {
			break
		}

		return e.complexity.TradeActorWallet.WalletID(childComplexity), true

	case "TradeOffer.ClosedAt":
		if e.complexity.TradeOffer.ClosedAt == nil {
			break
		}

		return e.complexity.TradeOffer.ClosedAt(childComplexity), true

	case "TradeOffer.ComType":
		if e.complexity.TradeOffer.ComType == nil {
			break
		}

		return e.complexity.TradeOffer.ComType(childComplexity), true

	case "TradeOffer.Commodity":
		if e.complexity.TradeOffer.Commodity == nil {
			break
		}

		return e.complexity.TradeOffer.Commodity(childComplexity), true

	case "TradeOffer.CreatedAt":
		if e.complexity.TradeOffer.CreatedAt == nil {
			break
		}

		return e.complexity.TradeOffer.CreatedAt(childComplexity), true

	case "TradeOffer.CreatedBy":
		if e.complexity.TradeOffer.CreatedBy == nil {
			break
		}

		return e.complexity.TradeOffer.CreatedBy(childComplexity), true

	case "TradeOffer.Currency":
		if e.complexity.TradeOffer.Currency == nil {
			break
		}

		return e.complexity.TradeOffer.Currency(childComplexity), true

	case "TradeOffer.ExpiresAt":
		if e.complexity.TradeOffer.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeOffer.ExpiresAt(childComplexity), true

	case "TradeOffer.ID":
		if e.complexity.TradeOffer.ID == nil {
			break
		}

		return e.complexity.TradeOffer.ID(childComplexity), true

	case "TradeOffer.Incoterm":
		if e.complexity.TradeOffer.Incoterm == nil {
			break
		}

		return e.complexity.TradeOffer.Incoterm(childComplexity), true

	case "TradeOffer.IsAnonymous":
		if e.complexity.TradeOffer.IsAnonymous == nil {
			break
		}

		return e.complexity.TradeOffer.IsAnonymous(childComplexity), true

	case "TradeOffer.IsSell":
		if e.complexity.TradeOffer.IsSell == nil {
			break
		}

		return e.complexity.TradeOffer.IsSell(childComplexity), true

	case "TradeOffer.MarketLoc":
		if e.complexity.TradeOffer.MarketLoc == nil {
			break
		}

		return e.complexity.TradeOffer.MarketLoc(childComplexity), true

	case "TradeOffer.Note":
		if e.complexity.TradeOffer.Note == nil {
			break
		}

		return e.complexity.TradeOffer.Note(childComplexity), true

	case "TradeOffer.Org":
		if e.complexity.TradeOffer.Org == nil {
			break
		}

		return e.complexity.TradeOffer.Org(childComplexity), true

	case "TradeOffer.Origin":
		if e.complexity.TradeOffer.Origin == nil {
			break
		}

		return e.complexity.TradeOffer.Origin(childComplexity), true

	case "TradeOffer.Price":
		if e.complexity.TradeOffer.Price == nil {
			break
		}

		return e.complexity.TradeOffer.Price(childComplexity), true

	case "TradeOffer.PriceType":
		if e.complexity.TradeOffer.PriceType == nil {
			break
		}

		return e.complexity.TradeOffer.PriceType(childComplexity), true

	case "TradeOffer.Quality":
		if e.complexity.TradeOffer.Quality == nil {
			break
		}

		return e.complexity.TradeOffer.Quality(childComplexity), true

	case "TradeOffer.Shipment":
		if e.complexity.TradeOffer.Shipment == nil {
			break
		}

		return e.complexity.TradeOffer.Shipment(childComplexity), true

	case "TradeOffer.Terms":
		if e.complexity.TradeOffer.Terms == nil {
			break
		}

		return e.complexity.TradeOffer.Terms(childComplexity), true

	case "TradeOffer.Vol":
		if e.complexity.TradeOffer.Vol == nil {
			break
		}

		return e.complexity.TradeOffer.Vol(childComplexity), true

	case "TradeStage.AddReqIdx":
		if e.complexity.TradeStage.AddReqIdx == nil {
			break
		}

		return e.complexity.TradeStage.AddReqIdx(childComplexity), true

	case "TradeStage.CloseReqs":
		if e.complexity.TradeStage.CloseReqs == nil {
			break
		}

		return e.complexity.TradeStage.CloseReqs(childComplexity), true

	case "TradeStage.DelReqs":
		if e.complexity.TradeStage.DelReqs == nil {
			break
		}

		return e.complexity.TradeStage.DelReqs(childComplexity), true

	case "TradeStage.Description":
		if e.complexity.TradeStage.Description == nil {
			break
		}

		return e.complexity.TradeStage.Description(childComplexity), true

	case "TradeStage.Docs":
		if e.complexity.TradeStage.Docs == nil {
			break
		}

		return e.complexity.TradeStage.Docs(childComplexity), true

	case "TradeStage.ExpiresAt":
		if e.complexity.TradeStage.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeStage.ExpiresAt(childComplexity), true

	case "TradeStage.Moderator":
		if e.complexity.TradeStage.Moderator == nil {
			break
		}

		return e.complexity.TradeStage.Moderator(childComplexity), true

	case "TradeStage.Name":
		if e.complexity.TradeStage.Name == nil {
			break
		}

		return e.complexity.TradeStage.Name(childComplexity), true

	case "TradeStage.Owner":
		if e.complexity.TradeStage.Owner == nil {
			break
		}

		return e.complexity.TradeStage.Owner(childComplexity), true

	case "TradeStageAddReq.ApprovedAt":
		if e.complexity.TradeStageAddReq.ApprovedAt == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ApprovedAt(childComplexity), true

	case "TradeStageAddReq.ApprovedBy":
		if e.complexity.TradeStageAddReq.ApprovedBy == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ApprovedBy(childComplexity), true

	case "TradeStageAddReq.Description":
		if e.complexity.TradeStageAddReq.Description == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Description(childComplexity), true

	case "TradeStageAddReq.Name":
		if e.complexity.TradeStageAddReq.Name == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Name(childComplexity), true

	case "TradeStageAddReq.Owner":
		if e.complexity.TradeStageAddReq.Owner == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Owner(childComplexity), true

	case "TradeStageAddReq.RejectReason":
		if e.complexity.TradeStageAddReq.RejectReason == nil {
			break
		}

		return e.complexity.TradeStageAddReq.RejectReason(childComplexity), true

	case "TradeStageAddReq.ReqActor":
		if e.complexity.TradeStageAddReq.ReqActor == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqActor(childComplexity), true

	case "TradeStageAddReq.ReqAt":
		if e.complexity.TradeStageAddReq.ReqAt == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqAt(childComplexity), true

	case "TradeStageAddReq.ReqBy":
		if e.complexity.TradeStageAddReq.ReqBy == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqBy(childComplexity), true

	case "TradeStageAddReq.ReqReason":
		if e.complexity.TradeStageAddReq.ReqReason == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqReason(childComplexity), true

	case "TradeStageAddReq.Status":
		if e.complexity.TradeStageAddReq.Status == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Status(childComplexity), true

	case "TradeStageDoc.ApprovedAt":
		if e.complexity.TradeStageDoc.ApprovedAt == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedAt(childComplexity), true

	case "TradeStageDoc.ApprovedBy":
		if e.complexity.TradeStageDoc.ApprovedBy == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedBy(childComplexity), true

	case "TradeStageDoc.ApprovedTx":
		if e.complexity.TradeStageDoc.ApprovedTx == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedTx(childComplexity), true

	case "TradeStageDoc.Doc":
		if e.complexity.TradeStageDoc.Doc == nil {
			break
		}

		return e.complexity.TradeStageDoc.Doc(childComplexity), true

	case "TradeStageDoc.ExpiresAt":
		if e.complexity.TradeStageDoc.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeStageDoc.ExpiresAt(childComplexity), true

	case "TradeStageDoc.RejectReason":
		if e.complexity.TradeStageDoc.RejectReason == nil {
			break
		}

		return e.complexity.TradeStageDoc.RejectReason(childComplexity), true

	case "TradeStageDoc.ReqTx":
		if e.complexity.TradeStageDoc.ReqTx == nil {
			break
		}

		return e.complexity.TradeStageDoc.ReqTx(childComplexity), true

	case "TradeStageDoc.Status":
		if e.complexity.TradeStageDoc.Status == nil {
			break
		}

		return e.complexity.TradeStageDoc.Status(childComplexity), true

	case "TradeStageTemplate.Description":
		if e.complexity.TradeStageTemplate.Description == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Description(childComplexity), true

	case "TradeStageTemplate.Name":
		if e.complexity.TradeStageTemplate.Name == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Name(childComplexity), true

	case "TradeStageTemplate.Owner":
		if e.complexity.TradeStageTemplate.Owner == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Owner(childComplexity), true

	case "TradeTemplate.Description":
		if e.complexity.TradeTemplate.Description == nil {
			break
		}

		return e.complexity.TradeTemplate.Description(childComplexity), true

	case "TradeTemplate.ID":
		if e.complexity.TradeTemplate.ID == nil {
			break
		}

		return e.complexity.TradeTemplate.ID(childComplexity), true

	case "TradeTemplate.Name":
		if e.complexity.TradeTemplate.Name == nil {
			break
		}

		return e.complexity.TradeTemplate.Name(childComplexity), true

	case "TradeTemplate.Stages":
		if e.complexity.TradeTemplate.Stages == nil {
			break
		}

		return e.complexity.TradeTemplate.Stages(childComplexity), true

	case "User.Avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.Biography":
		if e.complexity.User.Biography == nil {
			break
		}

		return e.complexity.User.Biography(childComplexity), true

	case "User.CreatedAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.Emails":
		if e.complexity.User.Emails == nil {
			break
		}

		return e.complexity.User.Emails(childComplexity), true

	case "User.FirstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.LastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.OrgMap":
		if e.complexity.User.OrgMap == nil {
			break
		}

		return e.complexity.User.OrgMap(childComplexity), true

	case "User.PubKey":
		if e.complexity.User.PubKey == nil {
			break
		}

		return e.complexity.User.PubKey(childComplexity), true

	case "User.Roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserOrgMap.Org":
		if e.complexity.UserOrgMap.Org == nil {
			break
		}

		return e.complexity.UserOrgMap.Org(childComplexity), true

	case "UserOrgMap.Role":
		if e.complexity.UserOrgMap.Role == nil {
			break
		}

		return e.complexity.UserOrgMap.Role(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "websrv_schema.graphql", Input: `"Query defines all possible query types; Should be immutable"
type Query {
  "query single user by id; gets current user when id is null"
  user(id: ID): User
  "returns only approved users"
  users: [User!]!
  organizations: [Organization!]!
   "returns all users"
  adminUsers: [AdminUser!]!
  tradeTemplates: [TradeTemplate!]!
  trade(id: ID!): Trade
  trades: [Trade!]!

  tradeOffer(id: ID!): TradeOffer
  tradeOffers: [TradeOffer!]!
  "Retrieve current user's public key for this trade"

  notifications(from: Uint!): [Notification!]!
  notificationsTrade(id: String!): [Notification!]!

  stellarNet: StellarNet
  adminTrades: [Trade!]!
}

"""
The mutation type, represents all updates we can make to our data.
Principles:
+ Name mutation by the resource first and order them automatically
+ mutations should provide user/business-level errors via a
  userErrors field on the mutation payload
These operations change the state of the database
"""
type Mutation {
  userSignup(input: NewUserInput): Int
  userLogin(input: UserLoginInput!): AuthUser
  userPasswordChange(input: ChangePasswordInput!): Int
  userEmailChange(input: [Email!]!): Int
  userProfileUpdate(input: UserProfileInput!): User
  organizationCreate(input: OrgInput!): Organization

  tradeCreate(input: NewTradeInput!) : Trade
  tradeStageAddReq(input: NewStageInput!, signedTx: String!, withApproval: Boolean!): TradeStageAddReq
  tradeStageAddReqApprove(id: TradeStagePath!, signedTx: String!,): TradeStage
  tradeStageAddReqReject(id: TradeStagePath!, signedTx: String!, reason: String!): Int

  tradeStageDelReq(id: TradeStagePath!, reason: String!): ApproveReq
  tradeStageDelReqApprove(id: TradeStagePath!): ApproveReq
  tradeStageDelReqReject(id: TradeStagePath!, reason: String!): Int

  tradeStageCloseReq(id: TradeStagePath!, signedTx: String!, reason: String!): ApproveReq
  tradeStageCloseReqApprove(id: TradeStagePath!, signedTx: String!): ApproveReq
  tradeStageCloseReqReject(id: TradeStagePath!, signedTx: String!, reason: String!): Int
  tradeStageSetExpireTime(id: TradeStagePath!, expiresAt: String!): Int

  tradeCloseReq(id: String!, reason: String!, signedTx: String!): ApproveReq
  tradeCloseReqApprove(id: String!, signedTx: String!): ApproveReq
  tradeCloseReqReject(id: String!, reason: String!, signedTx: String!): Int

  tradeStageDocApprove(id: TradeStageDocPath!, signedTx: String!): TradeStageDoc
  tradeStageDocReject(id: TradeStageDocPath!, signedTx: String!, reason: String!): Int

  tradeOfferCreate(input: TradeOfferInput!): TradeOffer
  tradeOfferClose(id: String!): Int

  notificationDismiss(id: String!): Int

  mkTradeStageDocTx(id: TradeStageDocPath!, operationType: Approval!, expiresAt: Time): String!
  mkTradeStageCloseTx(id: TradeStagePath!, operationType: Approval!): String!
  "creates a new trade stage doc entry"
  mkTradeStageAddTx(id: TradeStagePath!, operationType: Approval!): String!
  mkTradeCloseTx(id: String!, operationType: Approval!): String!

  ### Admin mutations ###

  adminApproveUser(id: String!, status: SimpleApproval!, reason: String): AccessApproval
}

#####################
#   SCALARS

"Email field"
scalar Email
"Time field"
scalar Time
"Telephone number"
scalar Telephone
"Hash digest of file or other data. Presented as a Hex string"
scalar Hash
"Unsigned number"
scalar Uint

#####################
#   ENUMS

"Available user role options for authorization"
enum UserRole {
  "Trader is the participant of a trade. Can act on trade."
  trader
  "Moderator has supervisor privileges for trade"
  moderator
}

"Approval status of a trade or a stage"
enum Approval {
  nil
  pending
  expired
  rejected
  approved
  submitted
}

"Moderating status of a trade or a stage"
enum DoneStatus {
  nil
  doing
  done
}

"SimpleApproval is a basic status for approvals"
enum SimpleApproval {
  rejected
  approved
}

"Type of user that participates in trade"
enum TradeActor {
  "No Owner"
  n
  "Buyer"
  b
  "Seller"
  s
  "Moderator"
  m
}

"TxTradeEntity enums for transaction build"
enum TxTradeEntity {
   stage_doc
   stage_closeReqs
   stage_add
   trade_closeReqs
}

"Is it a firm offer or just a quote"
enum OfferPriceType {
  firm
  quote
}

"trading incoterm"
enum Incoterm {
  CAF
  CFR
  CFRC
  CIF
  CIFFO
  CNF
  CNFFO
  DEL
  FOB
}

enum Currency {
  USD
  RUB
  EUR
  TRY
  UAH
  CNY
}

enum NotifType {
  "triggered when a user perform some action and this triggers a notification for other users"
  action
  "triggered by a system when there is something to be do (eg documenet approval is close to expire)"
  alert
}

#####################
#   Input types

"New user input data"
input NewUserInput {
  firstName: String!
  lastName:  String!
  email:     Email!
  password:  String!
  avatar:    String
  publicKey: String!
  biography: String
  orgID:     String!
  orgRole:   String!
}

"User data for logging in"
input UserLoginInput {
  email:    Email!
  password: String!
}

"Trade creation fields"
input NewTradeInput {
  templateID:   ID!
  name:         String!
  sellerID:     ID!
  buyerID:      ID!
  description:  String
  tradeOfferID: String
}

"Context of a trade stage"
input TradeStagePath {
  tid:      ID!
  stageIdx: Uint!
}

"Context of a document"
input TradeStageDocPath {
  tid:          ID!
  stageIdx:     Uint!
  stageDocIdx:  Uint!
  stageDocHash: Hash!
}

"New trade fields"
input NewStageInput {
  tid:         ID!
  owner:       String!
  name:        String!
  description: String!
  reason:      String!
}

"Password change data"
input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

"Organization input data"
input OrgInput {
  name: String!
  address: String!
  telephone: Telephone!
  email: Email!
}

"User orgMap input"
input UserOrgMapInput {
  id:  String!
  role: String!
}

"User Profile update data"
input UserProfileInput {
  firstName: String!
  lastName:  String!
  orgMap:    [UserOrgMapInput!]
  biography: String!
}

"trade offer input data"
input TradeOfferInput {
  price:        Float!
  priceType:    OfferPriceType!
  isSell:       Boolean!
  currency:     Currency!
  expiresAt:    Time
  commodity:    String!
  comType:      [String!]!
  quality:      String!
  orgID:        String!
  origin:       String!
  isAnonymous:  Boolean!
  incoterm:     Incoterm!
  marketLoc:    String!
  vol:          Int!
  shipment:     [Time!]!
  note:         String!
  docID:        String
}

#####################
#   Resource types

"User data"
type User {
  id:        ID!
  firstName: String!
  lastName:  String!
  emails:    [Email!]
  roles:     [UserRole!]!
  avatar:    String!
  orgMap:    [UserOrgMap!]
  createdAt: Time!
  biography: String!
  pubKey:    String @deprecated
}

"AuthUser; after user login, backend sends user token"
type AuthUser {
  id:    ID!
  token: String!
}

"AdminUser; User with special Admin information"
type AdminUser {
  # ... on User
  user:       User
  approvals:   [AccessApproval!]!
}

type StageModerator {
  user:      User
  createdAt: Time
}

"User organization with role"
type UserOrgMap {
  org:  Organization!
  role: String!
}

"Organization data"
type Organization {
  id:       ID!
  name:     String!
  address:  String!
  telephone: Telephone!
  email:    Email!
}

"AccessAproval is a record representing a user approval for some access"
type AccessApproval {
  status:    SimpleApproval!
  approver:  User!
  reason:    String
  createdAt: Time!
}

"""
Approval request that can be approved or rejected
Used for creating stages and closing trades
"""
type ApproveReq {
  status:     Approval!
  reqActor:   TradeActor!
  reqBy:      User!
  reqAt:      Time!
  reqTx:  Hash
  reqReason:  String!
  approvedBy: User
  approvedAt: Time
  approvedTx: Hash
  rejectReason:   String
}

"Trade information"
type Trade {
  id:                ID!
  name:              String!
  description:       String!
  template:          TradeTemplate!
  buyer:             User!
  seller:            User!
  scAddr:            Hash!
  stages:            [TradeStage!]
  stageAddReqs:      [TradeStageAddReq!]
  closeReqs:         [ApproveReq!]!
  createdBy:         User!
  createdAt:         Time!
  tradeOffer:        TradeOffer
  moderating:        DoneStatus!
  actorWallet:       TradeActorWallet
}

"Trade stage add request"
type TradeStageAddReq {
  name:              String!
  description:       String!
  owner:             TradeActor!

  # ApproveReq fields
  status:       Approval!
  reqActor:     TradeActor!
  reqBy:        User!
  reqAt:        Time!
  reqReason:    String!
  approvedBy:   User
  approvedAt:   Time
  rejectReason: String
}

"Trade stage is a single step of a trade"
type TradeStage {
  name:        String!
  description: String!
  "index of addRequest of stage in trade"
  addReqIdx:   Int!
  owner:       TradeActor!
  expiresAt:   Time
  docs:        [TradeStageDoc!]!
  delReqs:     [ApproveReq!]!
  """
  Close requests. Can be closed only if stage is not deleted
  To compute the status of the stage you should use the following procedure.
  If ` + "`" + `closeReqs` + "`" + ` is empty then check then check the last element of delReqs.
  If it is approved then the stage is deleted.
  Else check the last element in ` + "`" + `closeReq` + "`" + `.
  """
  closeReqs:   [ApproveReq!]!
  moderator:   StageModerator
 }

"""
Trade stage document
Represents a single aggreement of a trade stage
Approval status is required for stage completeness
"""
type TradeStageDoc {
  doc:         Doc
  reqTx:       Hash
  status:      Approval!
  approvedBy:  User
  approvedAt:  Time
  approvedTx:  Hash
  expiresAt:   Time!
  rejectReason: String
}

"Document; Represents a single document saved to file"
type Doc {
  id:        ID!
  hash:      Hash!
  name:      String!
  note:      String!
  type:      String
  url:       String!
  createdBy: User!
  createdAt: Time!
}

"Trade template; Prefabricated blueprint for faster trade creation"
type TradeTemplate {
  id:          ID!
  name:        String!
  description: String!
  stages:      [TradeStageTemplate!]!
}

"Trade stage template; Prefabricated blueprint for faster stage creation"
type TradeStageTemplate {
  name:         String!
  description:  String!
  owner:        TradeActor!
}

"trade offer object"
type TradeOffer {
  id:        ID!
  price:     Float!
  isSell:    Boolean!
  priceType: OfferPriceType!
  currency:  Currency!
  createdBy: User!
  createdAt: Time!
  expiresAt: Time
  closedAt:  Time
  org:       Organization
  isAnonymous: Boolean!
  "commodity type"
  commodity: String!
  comType:   [String!]!
  quality:   String!
  origin:    String!
  incoterm:  Incoterm!
  marketLoc: String!
  "volumen - quantity"
  vol:       Int!
  "Shipment is a tuple representing: from-to"
  shipment:  [Time!]!
  note:      String!
  terms:     Doc
}

"StellarNet; stellar network infomation, we provide it to frontend"
type StellarNet {
  name:       String!
  url:        String!
  passphrase: String!
}

"Notification object"
type Notification {
  id:           ID!
  createdAt:    Time!
  triggeredBy:  User
  receiver:     [ID!]!
  type:         NotifType!
  dismissed:    [ID!]!
  entityID:     String!
  msg:          String!
  action:       Approval!
}

"TradeActorWallet; data about an actor in a trade"
type TradeActorWallet {
  pubKey:   String!
  keyPath:  String!
  walletID: String!
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_adminApproveUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.SimpleApproval
	if tmp, ok := rawArgs["status"]; ok {
		arg1, err = ec.unmarshalNSimpleApproval2bitbucketorgcerealiaappsgolibmodelSimpleApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeCloseTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageAddTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageCloseTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageDocTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketorgcerealiaappsgolibmodelTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["expiresAt"]; ok {
		arg2, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["expiresAt"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_notificationDismiss_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_organizationCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.OrgInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNOrgInput2bitbucketorgcerealiaappsgolibmodelOrgInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewTradeInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNNewTradeInput2bitbucketorgcerealiaappsgolibmodelNewTradeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeOfferClose_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeOfferCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeOfferInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNTradeOfferInput2bitbucketorgcerealiaappsgolibmodelTradeOfferInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewStageInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNNewStageInput2bitbucketorgcerealiaappsgolibmodelNewStageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["withApproval"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["withApproval"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDocApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketorgcerealiaappsgolibmodelTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDocReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketorgcerealiaappsgolibmodelTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageSetExpireTime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["expiresAt"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["expiresAt"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_userEmailChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNEmail2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userLogin_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserLoginInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUserLoginInput2bitbucketorgcerealiaappsgolibmodelUserLoginInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userPasswordChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChangePasswordInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNChangePasswordInput2bitbucketorgcerealiaappsgolibmodelChangePasswordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userProfileUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserProfileInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUserProfileInput2bitbucketorgcerealiaappsgolibmodelUserProfileInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userSignup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.NewUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalONewUserInput2bitbucketorgcerealiaappsgolibmodelNewUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_notificationsTrade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_notifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["from"]; ok {
		arg0, err = ec.unmarshalNUint2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tradeOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_trade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AccessApproval_status(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SimpleApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSimpleApproval2bitbucketorgcerealiaappsgolibmodelSimpleApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_approver(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AccessApproval().Approver(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_reason(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _AdminUser_user(ctx context.Context, field graphql.CollectedField, obj *model.AdminUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AdminUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AdminUser_approvals(ctx context.Context, field graphql.CollectedField, obj *model.AdminUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AdminUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approvals, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AccessApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_status(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqActor(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqActor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqBy(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApproveReq().ReqBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqAt(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqTx(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqReason(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqReason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApproveReq().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedTx(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthUser_id(ctx context.Context, field graphql.CollectedField, obj *model.AuthUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuthUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthUser_token(ctx context.Context, field graphql.CollectedField, obj *model.AuthUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuthUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_id(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_hash(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_name(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_note(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_type(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_url(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Doc().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userSignup(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userSignup_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserSignup(rctx, args["input"].(*model.NewUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userLogin(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userLogin_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserLogin(rctx, args["input"].(model.UserLoginInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAuthUser2bitbucketorgcerealiaappsgolibmodelAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userPasswordChange(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userPasswordChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserPasswordChange(rctx, args["input"].(model.ChangePasswordInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userEmailChange(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userEmailChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserEmailChange(rctx, args["input"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userProfileUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userProfileUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserProfileUpdate(rctx, args["input"].(model.UserProfileInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_organizationCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_organizationCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OrganizationCreate(rctx, args["input"].(model.OrgInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCreate(rctx, args["input"].(model.NewTradeInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReq(rctx, args["input"].(model.NewStageInput), args["signedTx"].(string), args["withApproval"].(bool))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStageAddReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReqApprove(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReqReject(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReq(rctx, args["id"].(model.TradeStagePath), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReqApprove(rctx, args["id"].(model.TradeStagePath))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReqReject(rctx, args["id"].(model.TradeStagePath), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReq(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReqApprove(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReqReject(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageSetExpireTime(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageSetExpireTime_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageSetExpireTime(rctx, args["id"].(model.TradeStagePath), args["expiresAt"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReq(rctx, args["id"].(string), args["reason"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReqApprove(rctx, args["id"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReqReject(rctx, args["id"].(string), args["reason"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDocApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDocApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDocApprove(rctx, args["id"].(model.TradeStageDocPath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStageDoc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDocReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDocReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDocReject(rctx, args["id"].(model.TradeStageDocPath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeOfferCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeOfferCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeOfferCreate(rctx, args["input"].(model.TradeOfferInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeOfferClose(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeOfferClose_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeOfferClose(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_notificationDismiss(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_notificationDismiss_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NotificationDismiss(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageDocTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageDocTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageDocTx(rctx, args["id"].(model.TradeStageDocPath), args["operationType"].(model.Approval), args["expiresAt"].(*time.Time))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageCloseTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageCloseTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageCloseTx(rctx, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageAddTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageAddTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageAddTx(rctx, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeCloseTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeCloseTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeCloseTx(rctx, args["id"].(string), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_adminApproveUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_adminApproveUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminApproveUser(rctx, args["id"].(string), args["status"].(model.SimpleApproval), args["reason"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AccessApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_id(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_triggeredBy(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().TriggeredBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_receiver(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Receiver, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_type(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.NotifType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotifType2bitbucketorgcerealiaappsgolibmodelNotifType(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_dismissed(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dismissed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_entityID(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_msg(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_action(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_address(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_telephone(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telephone, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTelephone2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_email(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEmail2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_user_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_organizations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organizations(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adminUsers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminUsers(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AdminUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAdminUser2bitbucketorgcerealiaappsgolibmodelAdminUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeTemplates(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeTemplates(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trade(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_trade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trade(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trades(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trades(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeOffer(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_tradeOffer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeOffer(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeOffers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeOffers(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_notifications(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_notifications_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Notifications(rctx, args["from"].(uint))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotification2bitbucketorgcerealiaappsgolibmodelNotification(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_notificationsTrade(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_notificationsTrade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NotificationsTrade(rctx, args["id"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotification2bitbucketorgcerealiaappsgolibmodelNotification(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_stellarNet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StellarNet(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StellarNet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStellarNet2bitbucketorgcerealiaappsgolibmodelStellarNet(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adminTrades(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminTrades(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _StageModerator_user(ctx context.Context, field graphql.CollectedField, obj *model.StageModerator) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StageModerator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StageModerator().User(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _StageModerator_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.StageModerator) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StageModerator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_name(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_url(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_passphrase(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Passphrase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_id(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_name(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_description(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_template(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Template(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TradeTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buyer(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Buyer(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_seller(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Seller(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_scAddr(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().ScAddr(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_stages(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stages, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TradeStage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_stageAddReqs(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StageAddReqs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageAddReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_closeReqs(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_tradeOffer(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().TradeOffer(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_moderating(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moderating, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DoneStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDoneStatus2bitbucketorgcerealiaappsgolibmodelDoneStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_actorWallet(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().ActorWallet(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeActorWallet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeActorWallet2bitbucketorgcerealiaappsgolibmodelTradeActorWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_pubKey(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_keyPath(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyPath, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_walletID(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WalletID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_id(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_price(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_isSell(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSell, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_priceType(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriceType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.OfferPriceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOfferPriceType2bitbucketorgcerealiaappsgolibmodelOfferPriceType(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_currency(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Currency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2bitbucketorgcerealiaappsgolibmodelCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_closedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_org(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().Org(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_isAnonymous(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAnonymous, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_commodity(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commodity, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_comType(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ComType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_quality(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quality, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_origin(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_incoterm(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Incoterm, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Incoterm)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNIncoterm2bitbucketorgcerealiaappsgolibmodelIncoterm(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_marketLoc(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketLoc, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_vol(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vol, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_shipment(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shipment, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_note(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_terms(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().Terms(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODoc2bitbucketorgcerealiaappsgolibmodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_addReqIdx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddReqIdx, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_docs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Docs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageDoc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_delReqs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DelReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_closeReqs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_moderator(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moderator, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.StageModerator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStageModerator2bitbucketorgcerealiaappsgolibmodelStageModerator(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_status(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqActor(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqActor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageAddReq().ReqBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqReason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageAddReq().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_doc(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageDoc().Doc(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODoc2bitbucketorgcerealiaappsgolibmodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_reqTx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_status(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageDoc().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedTx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_id(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_stages(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stages, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeStageTemplate2bitbucketorgcerealiaappsgolibmodelTradeStageTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_firstName(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_lastName(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_emails(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Emails, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOEmail2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.UserRole)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) _User_avatar(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_orgMap(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().OrgMap(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UserOrgMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUserOrgMap2bitbucketorgcerealiaappsgolibmodelUserOrgMap(ctx, field.Selections, res)
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _User_biography(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Biography, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_pubKey(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().PubKey(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserOrgMap_org(ctx context.Context, field graphql.CollectedField, obj *model.UserOrgMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "UserOrgMap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Org, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _UserOrgMap_role(ctx context.Context, field graphql.CollectedField, obj *model.UserOrgMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "UserOrgMap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChangePasswordInput(ctx context.Context, v interface{}) (model.ChangePasswordInput, error) {
	var it model.ChangePasswordInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "oldPassword":
			var err error
			it.OldPassword, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "newPassword":
			var err error
			it.NewPassword, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewStageInput(ctx context.Context, v interface{}) (model.NewStageInput, error) {
	var it model.NewStageInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTradeInput(ctx context.Context, v interface{}) (model.NewTradeInput, error) {
	var it model.NewTradeInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "templateID":
			var err error
			it.TemplateID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sellerID":
			var err error
			it.SellerID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "buyerID":
			var err error
			it.BuyerID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeOfferID":
			var err error
			it.TradeOfferID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	var it model.NewUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "firstName":
			var err error
			it.FirstName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName":
			var err error
			it.LastName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatar":
			var err error
			it.Avatar, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicKey":
			var err error
			it.PublicKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biography":
			var err error
			it.Biography, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgID":
			var err error
			it.OrgID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgRole":
			var err error
			it.OrgRole, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrgInput(ctx context.Context, v interface{}) (model.OrgInput, error) {
	var it model.OrgInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "address":
			var err error
			it.Address, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "telephone":
			var err error
			it.Telephone, err = ec.unmarshalNTelephone2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeOfferInput(ctx context.Context, v interface{}) (model.TradeOfferInput, error) {
	var it model.TradeOfferInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "price":
			var err error
			it.Price, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "priceType":
			var err error
			it.PriceType, err = ec.unmarshalNOfferPriceType2bitbucketorgcerealiaappsgolibmodelOfferPriceType(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSell":
			var err error
			it.IsSell, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNCurrency2bitbucketorgcerealiaappsgolibmodelCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAt":
			var err error
			it.ExpiresAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "commodity":
			var err error
			it.Commodity, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comType":
			var err error
			it.ComType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "quality":
			var err error
			it.Quality, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgID":
			var err error
			it.OrgID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "origin":
			var err error
			it.Origin, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnonymous":
			var err error
			it.IsAnonymous, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "incoterm":
			var err error
			it.Incoterm, err = ec.unmarshalNIncoterm2bitbucketorgcerealiaappsgolibmodelIncoterm(ctx, v)
			if err != nil {
				return it, err
			}
		case "marketLoc":
			var err error
			it.MarketLoc, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vol":
			var err error
			it.Vol, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "shipment":
			var err error
			it.Shipment, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "docID":
			var err error
			it.DocID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeStageDocPath(ctx context.Context, v interface{}) (model.TradeStageDocPath, error) {
	var it model.TradeStageDocPath
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageIdx":
			var err error
			it.StageIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageDocIdx":
			var err error
			it.StageDocIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageDocHash":
			var err error
			it.StageDocHash, err = ec.unmarshalNHash2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeStagePath(ctx context.Context, v interface{}) (model.TradeStagePath, error) {
	var it model.TradeStagePath
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageIdx":
			var err error
			it.StageIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserLoginInput(ctx context.Context, v interface{}) (model.UserLoginInput, error) {
	var it model.UserLoginInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrgMapInput(ctx context.Context, v interface{}) (model.UserOrgMapInput, error) {
	var it model.UserOrgMapInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserProfileInput(ctx context.Context, v interface{}) (model.UserProfileInput, error) {
	var it model.UserProfileInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "firstName":
			var err error
			it.FirstName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName":
			var err error
			it.LastName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgMap":
			var err error
			it.OrgMap, err = ec.unmarshalOUserOrgMapInput2bitbucketorgcerealiaappsgolibmodelUserOrgMapInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "biography":
			var err error
			it.Biography, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accessApprovalImplementors = []string{"AccessApproval"}

func (ec *executionContext) _AccessApproval(ctx context.Context, sel ast.SelectionSet, obj *model.AccessApproval) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, accessApprovalImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessApproval")
		case "status":
			out.Values[i] = ec._AccessApproval_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approver":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AccessApproval_approver(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reason":
			out.Values[i] = ec._AccessApproval_reason(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._AccessApproval_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var adminUserImplementors = []string{"AdminUser"}

func (ec *executionContext) _AdminUser(ctx context.Context, sel ast.SelectionSet, obj *model.AdminUser) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, adminUserImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminUser")
		case "user":
			out.Values[i] = ec._AdminUser_user(ctx, field, obj)
		case "approvals":
			out.Values[i] = ec._AdminUser_approvals(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var approveReqImplementors = []string{"ApproveReq"}

func (ec *executionContext) _ApproveReq(ctx context.Context, sel ast.SelectionSet, obj *model.ApproveReq) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, approveReqImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApproveReq")
		case "status":
			out.Values[i] = ec._ApproveReq_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqActor":
			out.Values[i] = ec._ApproveReq_reqActor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApproveReq_reqBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reqAt":
			out.Values[i] = ec._ApproveReq_reqAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqTx":
			out.Values[i] = ec._ApproveReq_reqTx(ctx, field, obj)
		case "reqReason":
			out.Values[i] = ec._ApproveReq_reqReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApproveReq_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._ApproveReq_approvedAt(ctx, field, obj)
		case "approvedTx":
			out.Values[i] = ec._ApproveReq_approvedTx(ctx, field, obj)
		case "rejectReason":
			out.Values[i] = ec._ApproveReq_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *model.AuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, authUserImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "id":
			out.Values[i] = ec._AuthUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "token":
			out.Values[i] = ec._AuthUser_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var docImplementors = []string{"Doc"}

func (ec *executionContext) _Doc(ctx context.Context, sel ast.SelectionSet, obj *model.Doc) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, docImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Doc")
		case "id":
			out.Values[i] = ec._Doc_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hash":
			out.Values[i] = ec._Doc_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Doc_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "note":
			out.Values[i] = ec._Doc_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Doc_type(ctx, field, obj)
		case "url":
			out.Values[i] = ec._Doc_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Doc_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._Doc_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "userSignup":
			out.Values[i] = ec._Mutation_userSignup(ctx, field)
		case "userLogin":
			out.Values[i] = ec._Mutation_userLogin(ctx, field)
		case "userPasswordChange":
			out.Values[i] = ec._Mutation_userPasswordChange(ctx, field)
		case "userEmailChange":
			out.Values[i] = ec._Mutation_userEmailChange(ctx, field)
		case "userProfileUpdate":
			out.Values[i] = ec._Mutation_userProfileUpdate(ctx, field)
		case "organizationCreate":
			out.Values[i] = ec._Mutation_organizationCreate(ctx, field)
		case "tradeCreate":
			out.Values[i] = ec._Mutation_tradeCreate(ctx, field)
		case "tradeStageAddReq":
			out.Values[i] = ec._Mutation_tradeStageAddReq(ctx, field)
		case "tradeStageAddReqApprove":
			out.Values[i] = ec._Mutation_tradeStageAddReqApprove(ctx, field)
		case "tradeStageAddReqReject":
			out.Values[i] = ec._Mutation_tradeStageAddReqReject(ctx, field)
		case "tradeStageDelReq":
			out.Values[i] = ec._Mutation_tradeStageDelReq(ctx, field)
		case "tradeStageDelReqApprove":
			out.Values[i] = ec._Mutation_tradeStageDelReqApprove(ctx, field)
		case "tradeStageDelReqReject":
			out.Values[i] = ec._Mutation_tradeStageDelReqReject(ctx, field)
		case "tradeStageCloseReq":
			out.Values[i] = ec._Mutation_tradeStageCloseReq(ctx, field)
		case "tradeStageCloseReqApprove":
			out.Values[i] = ec._Mutation_tradeStageCloseReqApprove(ctx, field)
		case "tradeStageCloseReqReject":
			out.Values[i] = ec._Mutation_tradeStageCloseReqReject(ctx, field)
		case "tradeStageSetExpireTime":
			out.Values[i] = ec._Mutation_tradeStageSetExpireTime(ctx, field)
		case "tradeCloseReq":
			out.Values[i] = ec._Mutation_tradeCloseReq(ctx, field)
		case "tradeCloseReqApprove":
			out.Values[i] = ec._Mutation_tradeCloseReqApprove(ctx, field)
		case "tradeCloseReqReject":
			out.Values[i] = ec._Mutation_tradeCloseReqReject(ctx, field)
		case "tradeStageDocApprove":
			out.Values[i] = ec._Mutation_tradeStageDocApprove(ctx, field)
		case "tradeStageDocReject":
			out.Values[i] = ec._Mutation_tradeStageDocReject(ctx, field)
		case "tradeOfferCreate":
			out.Values[i] = ec._Mutation_tradeOfferCreate(ctx, field)
		case "tradeOfferClose":
			out.Values[i] = ec._Mutation_tradeOfferClose(ctx, field)
		case "notificationDismiss":
			out.Values[i] = ec._Mutation_notificationDismiss(ctx, field)
		case "mkTradeStageDocTx":
			out.Values[i] = ec._Mutation_mkTradeStageDocTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeStageCloseTx":
			out.Values[i] = ec._Mutation_mkTradeStageCloseTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeStageAddTx":
			out.Values[i] = ec._Mutation_mkTradeStageAddTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeCloseTx":
			out.Values[i] = ec._Mutation_mkTradeCloseTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "adminApproveUser":
			out.Values[i] = ec._Mutation_adminApproveUser(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var notificationImplementors = []string{"Notification"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *model.Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, notificationImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "id":
			out.Values[i] = ec._Notification_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdAt":
			out.Values[i] = ec._Notification_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "triggeredBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_triggeredBy(ctx, field, obj)
				return res
			})
		case "receiver":
			out.Values[i] = ec._Notification_receiver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Notification_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dismissed":
			out.Values[i] = ec._Notification_dismissed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "entityID":
			out.Values[i] = ec._Notification_entityID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "msg":
			out.Values[i] = ec._Notification_msg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "action":
			out.Values[i] = ec._Notification_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "address":
			out.Values[i] = ec._Organization_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "telephone":
			out.Values[i] = ec._Organization_telephone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "email":
			out.Values[i] = ec._Organization_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "organizations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizations(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "adminUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminUsers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "tradeTemplates":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeTemplates(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "trade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trade(ctx, field)
				return res
			})
		case "trades":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trades(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "tradeOffer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeOffer(ctx, field)
				return res
			})
		case "tradeOffers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeOffers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "notifications":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notifications(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "notificationsTrade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notificationsTrade(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stellarNet":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stellarNet(ctx, field)
				return res
			})
		case "adminTrades":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminTrades(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var stageModeratorImplementors = []string{"StageModerator"}

func (ec *executionContext) _StageModerator(ctx context.Context, sel ast.SelectionSet, obj *model.StageModerator) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stageModeratorImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StageModerator")
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StageModerator_user(ctx, field, obj)
				return res
			})
		case "createdAt":
			out.Values[i] = ec._StageModerator_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var stellarNetImplementors = []string{"StellarNet"}

func (ec *executionContext) _StellarNet(ctx context.Context, sel ast.SelectionSet, obj *model.StellarNet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stellarNetImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StellarNet")
		case "name":
			out.Values[i] = ec._StellarNet_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._StellarNet_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "passphrase":
			out.Values[i] = ec._StellarNet_passphrase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeImplementors = []string{"Trade"}

func (ec *executionContext) _Trade(ctx context.Context, sel ast.SelectionSet, obj *model.Trade) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trade")
		case "id":
			out.Values[i] = ec._Trade_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Trade_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Trade_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "template":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_template(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "buyer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_buyer(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "seller":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_seller(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "scAddr":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_scAddr(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stages":
			out.Values[i] = ec._Trade_stages(ctx, field, obj)
		case "stageAddReqs":
			out.Values[i] = ec._Trade_stageAddReqs(ctx, field, obj)
		case "closeReqs":
			out.Values[i] = ec._Trade_closeReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._Trade_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tradeOffer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_tradeOffer(ctx, field, obj)
				return res
			})
		case "moderating":
			out.Values[i] = ec._Trade_moderating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "actorWallet":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_actorWallet(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeActorWalletImplementors = []string{"TradeActorWallet"}

func (ec *executionContext) _TradeActorWallet(ctx context.Context, sel ast.SelectionSet, obj *model.TradeActorWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeActorWalletImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeActorWallet")
		case "pubKey":
			out.Values[i] = ec._TradeActorWallet_pubKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "keyPath":
			out.Values[i] = ec._TradeActorWallet_keyPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "walletID":
			out.Values[i] = ec._TradeActorWallet_walletID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeOfferImplementors = []string{"TradeOffer"}

func (ec *executionContext) _TradeOffer(ctx context.Context, sel ast.SelectionSet, obj *model.TradeOffer) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeOfferImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeOffer")
		case "id":
			out.Values[i] = ec._TradeOffer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._TradeOffer_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isSell":
			out.Values[i] = ec._TradeOffer_isSell(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "priceType":
			out.Values[i] = ec._TradeOffer_priceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "currency":
			out.Values[i] = ec._TradeOffer_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._TradeOffer_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expiresAt":
			out.Values[i] = ec._TradeOffer_expiresAt(ctx, field, obj)
		case "closedAt":
			out.Values[i] = ec._TradeOffer_closedAt(ctx, field, obj)
		case "org":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_org(ctx, field, obj)
				return res
			})
		case "isAnonymous":
			out.Values[i] = ec._TradeOffer_isAnonymous(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "commodity":
			out.Values[i] = ec._TradeOffer_commodity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "comType":
			out.Values[i] = ec._TradeOffer_comType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "quality":
			out.Values[i] = ec._TradeOffer_quality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "origin":
			out.Values[i] = ec._TradeOffer_origin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "incoterm":
			out.Values[i] = ec._TradeOffer_incoterm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "marketLoc":
			out.Values[i] = ec._TradeOffer_marketLoc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "vol":
			out.Values[i] = ec._TradeOffer_vol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "shipment":
			out.Values[i] = ec._TradeOffer_shipment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "note":
			out.Values[i] = ec._TradeOffer_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "terms":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_terms(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageImplementors = []string{"TradeStage"}

func (ec *executionContext) _TradeStage(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStage")
		case "name":
			out.Values[i] = ec._TradeStage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStage_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addReqIdx":
			out.Values[i] = ec._TradeStage_addReqIdx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStage_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expiresAt":
			out.Values[i] = ec._TradeStage_expiresAt(ctx, field, obj)
		case "docs":
			out.Values[i] = ec._TradeStage_docs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "delReqs":
			out.Values[i] = ec._TradeStage_delReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "closeReqs":
			out.Values[i] = ec._TradeStage_closeReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "moderator":
			out.Values[i] = ec._TradeStage_moderator(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageAddReqImplementors = []string{"TradeStageAddReq"}

func (ec *executionContext) _TradeStageAddReq(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageAddReq) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageAddReqImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageAddReq")
		case "name":
			out.Values[i] = ec._TradeStageAddReq_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStageAddReq_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStageAddReq_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._TradeStageAddReq_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqActor":
			out.Values[i] = ec._TradeStageAddReq_reqActor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageAddReq_reqBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reqAt":
			out.Values[i] = ec._TradeStageAddReq_reqAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqReason":
			out.Values[i] = ec._TradeStageAddReq_reqReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageAddReq_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._TradeStageAddReq_approvedAt(ctx, field, obj)
		case "rejectReason":
			out.Values[i] = ec._TradeStageAddReq_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageDocImplementors = []string{"TradeStageDoc"}

func (ec *executionContext) _TradeStageDoc(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageDoc) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageDocImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageDoc")
		case "doc":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageDoc_doc(ctx, field, obj)
				return res
			})
		case "reqTx":
			out.Values[i] = ec._TradeStageDoc_reqTx(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TradeStageDoc_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageDoc_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._TradeStageDoc_approvedAt(ctx, field, obj)
		case "approvedTx":
			out.Values[i] = ec._TradeStageDoc_approvedTx(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._TradeStageDoc_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rejectReason":
			out.Values[i] = ec._TradeStageDoc_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageTemplateImplementors = []string{"TradeStageTemplate"}

func (ec *executionContext) _TradeStageTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageTemplate")
		case "name":
			out.Values[i] = ec._TradeStageTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStageTemplate_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStageTemplate_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeTemplateImplementors = []string{"TradeTemplate"}

func (ec *executionContext) _TradeTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.TradeTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeTemplate")
		case "id":
			out.Values[i] = ec._TradeTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._TradeTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeTemplate_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "stages":
			out.Values[i] = ec._TradeTemplate_stages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "firstName":
			out.Values[i] = ec._User_firstName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastName":
			out.Values[i] = ec._User_lastName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "emails":
			out.Values[i] = ec._User_emails(ctx, field, obj)
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "avatar":
			out.Values[i] = ec._User_avatar(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "orgMap":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_orgMap(ctx, field, obj)
				return res
			})
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "biography":
			out.Values[i] = ec._User_biography(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pubKey":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_pubKey(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var userOrgMapImplementors = []string{"UserOrgMap"}

func (ec *executionContext) _UserOrgMap(ctx context.Context, sel ast.SelectionSet, obj *model.UserOrgMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userOrgMapImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserOrgMap")
		case "org":
			out.Values[i] = ec._UserOrgMap_org(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "role":
			out.Values[i] = ec._UserOrgMap_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx context.Context, sel ast.SelectionSet, v model.AccessApproval) graphql.Marshaler {
	return ec._AccessApproval(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx context.Context, sel ast.SelectionSet, v []model.AccessApproval) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAdminUser2bitbucketorgcerealiaappsgolibmodelAdminUser(ctx context.Context, sel ast.SelectionSet, v model.AdminUser) graphql.Marshaler {
	return ec._AdminUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminUser2bitbucketorgcerealiaappsgolibmodelAdminUser(ctx context.Context, sel ast.SelectionSet, v []model.AdminUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminUser2bitbucketorgcerealiaappsgolibmodelAdminUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx context.Context, v interface{}) (model.Approval, error) {
	var res model.Approval
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNApproval2bitbucketorgcerealiaappsgolibmodelApproval(ctx context.Context, sel ast.SelectionSet, v model.Approval) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx context.Context, sel ast.SelectionSet, v model.ApproveReq) graphql.Marshaler {
	return ec._ApproveReq(ctx, sel, &v)
}

func (ec *executionContext) marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx context.Context, sel ast.SelectionSet, v []model.ApproveReq) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalNChangePasswordInput2bitbucketorgcerealiaappsgolibmodelChangePasswordInput(ctx context.Context, v interface{}) (model.ChangePasswordInput, error) {
	return ec.unmarshalInputChangePasswordInput(ctx, v)
}

func (ec *executionContext) unmarshalNCurrency2bitbucketorgcerealiaappsgolibmodelCurrency(ctx context.Context, v interface{}) (model.Currency, error) {
	var res model.Currency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNCurrency2bitbucketorgcerealiaappsgolibmodelCurrency(ctx context.Context, sel ast.SelectionSet, v model.Currency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDoneStatus2bitbucketorgcerealiaappsgolibmodelDoneStatus(ctx context.Context, v interface{}) (model.DoneStatus, error) {
	var res model.DoneStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNDoneStatus2bitbucketorgcerealiaappsgolibmodelDoneStatus(ctx context.Context, sel ast.SelectionSet, v model.DoneStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEmail2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalEmail(v)
}

func (ec *executionContext) marshalNEmail2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalEmail(v)
}

func (ec *executionContext) unmarshalNEmail2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNEmail2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNEmail2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNEmail2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalNHash2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalHash(v)
}

func (ec *executionContext) marshalNHash2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalHash(v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNIncoterm2bitbucketorgcerealiaappsgolibmodelIncoterm(ctx context.Context, v interface{}) (model.Incoterm, error) {
	var res model.Incoterm
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNIncoterm2bitbucketorgcerealiaappsgolibmodelIncoterm(ctx context.Context, sel ast.SelectionSet, v model.Incoterm) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalNNewStageInput2bitbucketorgcerealiaappsgolibmodelNewStageInput(ctx context.Context, v interface{}) (model.NewStageInput, error) {
	return ec.unmarshalInputNewStageInput(ctx, v)
}

func (ec *executionContext) unmarshalNNewTradeInput2bitbucketorgcerealiaappsgolibmodelNewTradeInput(ctx context.Context, v interface{}) (model.NewTradeInput, error) {
	return ec.unmarshalInputNewTradeInput(ctx, v)
}

func (ec *executionContext) unmarshalNNotifType2bitbucketorgcerealiaappsgolibmodelNotifType(ctx context.Context, v interface{}) (model.NotifType, error) {
	var res model.NotifType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNNotifType2bitbucketorgcerealiaappsgolibmodelNotifType(ctx context.Context, sel ast.SelectionSet, v model.NotifType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNNotification2bitbucketorgcerealiaappsgolibmodelNotification(ctx context.Context, sel ast.SelectionSet, v model.Notification) graphql.Marshaler {
	return ec._Notification(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotification2bitbucketorgcerealiaappsgolibmodelNotification(ctx context.Context, sel ast.SelectionSet, v []model.Notification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2bitbucketorgcerealiaappsgolibmodelNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNOfferPriceType2bitbucketorgcerealiaappsgolibmodelOfferPriceType(ctx context.Context, v interface{}) (model.OfferPriceType, error) {
	var res model.OfferPriceType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNOfferPriceType2bitbucketorgcerealiaappsgolibmodelOfferPriceType(ctx context.Context, sel ast.SelectionSet, v model.OfferPriceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNOrgInput2bitbucketorgcerealiaappsgolibmodelOrgInput(ctx context.Context, v interface{}) (model.OrgInput, error) {
	return ec.unmarshalInputOrgInput(ctx, v)
}

func (ec *executionContext) marshalNOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx context.Context, sel ast.SelectionSet, v []model.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNSimpleApproval2bitbucketorgcerealiaappsgolibmodelSimpleApproval(ctx context.Context, v interface{}) (model.SimpleApproval, error) {
	var res model.SimpleApproval
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSimpleApproval2bitbucketorgcerealiaappsgolibmodelSimpleApproval(ctx context.Context, sel ast.SelectionSet, v model.SimpleApproval) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.marshalNString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalNTelephone2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalTelephone(v)
}

func (ec *executionContext) marshalNTelephone2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalTelephone(v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return model.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	if v.IsZero() {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return model.MarshalTime(v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx context.Context, sel ast.SelectionSet, v model.Trade) graphql.Marshaler {
	return ec._Trade(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx context.Context, sel ast.SelectionSet, v []model.Trade) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx context.Context, v interface{}) (model.TradeActor, error) {
	var res model.TradeActor
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNTradeActor2bitbucketorgcerealiaappsgolibmodelTradeActor(ctx context.Context, sel ast.SelectionSet, v model.TradeActor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx context.Context, sel ast.SelectionSet, v model.TradeOffer) graphql.Marshaler {
	return ec._TradeOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx context.Context, sel ast.SelectionSet, v []model.TradeOffer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeOfferInput2bitbucketorgcerealiaappsgolibmodelTradeOfferInput(ctx context.Context, v interface{}) (model.TradeOfferInput, error) {
	return ec.unmarshalInputTradeOfferInput(ctx, v)
}

func (ec *executionContext) marshalNTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx context.Context, sel ast.SelectionSet, v model.TradeStage) graphql.Marshaler {
	return ec._TradeStage(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v model.TradeStageAddReq) graphql.Marshaler {
	return ec._TradeStageAddReq(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v model.TradeStageDoc) graphql.Marshaler {
	return ec._TradeStageDoc(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageDoc) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeStageDocPath2bitbucketorgcerealiaappsgolibmodelTradeStageDocPath(ctx context.Context, v interface{}) (model.TradeStageDocPath, error) {
	return ec.unmarshalInputTradeStageDocPath(ctx, v)
}

func (ec *executionContext) unmarshalNTradeStagePath2bitbucketorgcerealiaappsgolibmodelTradeStagePath(ctx context.Context, v interface{}) (model.TradeStagePath, error) {
	return ec.unmarshalInputTradeStagePath(ctx, v)
}

func (ec *executionContext) marshalNTradeStageTemplate2bitbucketorgcerealiaappsgolibmodelTradeStageTemplate(ctx context.Context, sel ast.SelectionSet, v model.TradeStageTemplate) graphql.Marshaler {
	return ec._TradeStageTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageTemplate2bitbucketorgcerealiaappsgolibmodelTradeStageTemplate(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageTemplate2bitbucketorgcerealiaappsgolibmodelTradeStageTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx context.Context, sel ast.SelectionSet, v model.TradeTemplate) graphql.Marshaler {
	return ec._TradeTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx context.Context, sel ast.SelectionSet, v []model.TradeTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTradeTemplate2bitbucketorgcerealiaappsgolibmodelTradeTemplate(ctx context.Context, sel ast.SelectionSet, v *model.TradeTemplate) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TradeTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint2uint(ctx context.Context, v interface{}) (uint, error) {
	return model.UnmarshalUint(v)
}

func (ec *executionContext) marshalNUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	return model.MarshalUint(v)
}

func (ec *executionContext) marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx context.Context, sel ast.SelectionSet, v []model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2bitbucketorgcerealiaappsgolibmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserLoginInput2bitbucketorgcerealiaappsgolibmodelUserLoginInput(ctx context.Context, v interface{}) (model.UserLoginInput, error) {
	return ec.unmarshalInputUserLoginInput(ctx, v)
}

func (ec *executionContext) marshalNUserOrgMap2bitbucketorgcerealiaappsgolibmodelUserOrgMap(ctx context.Context, sel ast.SelectionSet, v model.UserOrgMap) graphql.Marshaler {
	return ec._UserOrgMap(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUserOrgMapInput2bitbucketorgcerealiaappsgolibmodelUserOrgMapInput(ctx context.Context, v interface{}) (model.UserOrgMapInput, error) {
	return ec.unmarshalInputUserOrgMapInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserProfileInput2bitbucketorgcerealiaappsgolibmodelUserProfileInput(ctx context.Context, v interface{}) (model.UserProfileInput, error) {
	return ec.unmarshalInputUserProfileInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx context.Context, v interface{}) (model.UserRole, error) {
	var res model.UserRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx context.Context, v interface{}) ([]model.UserRole, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]model.UserRole, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx context.Context, sel ast.SelectionSet, v []model.UserRole) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserRole2bitbucketorgcerealiaappsgolibmodelUserRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Directive2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalOAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx context.Context, sel ast.SelectionSet, v model.AccessApproval) graphql.Marshaler {
	return ec._AccessApproval(ctx, sel, &v)
}

func (ec *executionContext) marshalOAccessApproval2bitbucketorgcerealiaappsgolibmodelAccessApproval(ctx context.Context, sel ast.SelectionSet, v *model.AccessApproval) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccessApproval(ctx, sel, v)
}

func (ec *executionContext) marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx context.Context, sel ast.SelectionSet, v model.ApproveReq) graphql.Marshaler {
	return ec._ApproveReq(ctx, sel, &v)
}

func (ec *executionContext) marshalOApproveReq2bitbucketorgcerealiaappsgolibmodelApproveReq(ctx context.Context, sel ast.SelectionSet, v *model.ApproveReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApproveReq(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthUser2bitbucketorgcerealiaappsgolibmodelAuthUser(ctx context.Context, sel ast.SelectionSet, v model.AuthUser) graphql.Marshaler {
	return ec._AuthUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAuthUser2bitbucketorgcerealiaappsgolibmodelAuthUser(ctx context.Context, sel ast.SelectionSet, v *model.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalODoc2bitbucketorgcerealiaappsgolibmodelDoc(ctx context.Context, sel ast.SelectionSet, v model.Doc) graphql.Marshaler {
	return ec._Doc(ctx, sel, &v)
}

func (ec *executionContext) marshalODoc2bitbucketorgcerealiaappsgolibmodelDoc(ctx context.Context, sel ast.SelectionSet, v *model.Doc) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Doc(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmail2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNEmail2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEmail2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNEmail2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOHash2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalHash(v)
}

func (ec *executionContext) marshalOHash2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalHash(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalONewUserInput2bitbucketorgcerealiaappsgolibmodelNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	return ec.unmarshalInputNewUserInput(ctx, v)
}

func (ec *executionContext) unmarshalONewUserInput2bitbucketorgcerealiaappsgolibmodelNewUserInput(ctx context.Context, v interface{}) (*model.NewUserInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalONewUserInput2bitbucketorgcerealiaappsgolibmodelNewUserInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalOOrganization2bitbucketorgcerealiaappsgolibmodelOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalOStageModerator2bitbucketorgcerealiaappsgolibmodelStageModerator(ctx context.Context, sel ast.SelectionSet, v model.StageModerator) graphql.Marshaler {
	return ec._StageModerator(ctx, sel, &v)
}

func (ec *executionContext) marshalOStellarNet2bitbucketorgcerealiaappsgolibmodelStellarNet(ctx context.Context, sel ast.SelectionSet, v model.StellarNet) graphql.Marshaler {
	return ec._StellarNet(ctx, sel, &v)
}

func (ec *executionContext) marshalOStellarNet2bitbucketorgcerealiaappsgolibmodelStellarNet(ctx context.Context, sel ast.SelectionSet, v *model.StellarNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StellarNet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return model.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	if v.IsZero() {
		return graphql.Null
	}
	return model.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeTime(ctx, sel, *v)
}

func (ec *executionContext) marshalOTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx context.Context, sel ast.SelectionSet, v model.Trade) graphql.Marshaler {
	return ec._Trade(ctx, sel, &v)
}

func (ec *executionContext) marshalOTrade2bitbucketorgcerealiaappsgolibmodelTrade(ctx context.Context, sel ast.SelectionSet, v *model.Trade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Trade(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeActorWallet2bitbucketorgcerealiaappsgolibmodelTradeActorWallet(ctx context.Context, sel ast.SelectionSet, v model.TradeActorWallet) graphql.Marshaler {
	return ec._TradeActorWallet(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeActorWallet2bitbucketorgcerealiaappsgolibmodelTradeActorWallet(ctx context.Context, sel ast.SelectionSet, v *model.TradeActorWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeActorWallet(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx context.Context, sel ast.SelectionSet, v model.TradeOffer) graphql.Marshaler {
	return ec._TradeOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeOffer2bitbucketorgcerealiaappsgolibmodelTradeOffer(ctx context.Context, sel ast.SelectionSet, v *model.TradeOffer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeOffer(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx context.Context, sel ast.SelectionSet, v model.TradeStage) graphql.Marshaler {
	return ec._TradeStage(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx context.Context, sel ast.SelectionSet, v []model.TradeStage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTradeStage2bitbucketorgcerealiaappsgolibmodelTradeStage(ctx context.Context, sel ast.SelectionSet, v *model.TradeStage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStage(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v model.TradeStageAddReq) graphql.Marshaler {
	return ec._TradeStageAddReq(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageAddReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTradeStageAddReq2bitbucketorgcerealiaappsgolibmodelTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v *model.TradeStageAddReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStageAddReq(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v model.TradeStageDoc) graphql.Marshaler {
	return ec._TradeStageDoc(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStageDoc2bitbucketorgcerealiaappsgolibmodelTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v *model.TradeStageDoc) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStageDoc(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2bitbucketorgcerealiaappsgolibmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserOrgMap2bitbucketorgcerealiaappsgolibmodelUserOrgMap(ctx context.Context, sel ast.SelectionSet, v []model.UserOrgMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserOrgMap2bitbucketorgcerealiaappsgolibmodelUserOrgMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOUserOrgMapInput2bitbucketorgcerealiaappsgolibmodelUserOrgMapInput(ctx context.Context, v interface{}) ([]model.UserOrgMapInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]model.UserOrgMapInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserOrgMapInput2bitbucketorgcerealiaappsgolibmodelUserOrgMapInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2bitbucketorgcerealiaappsvendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
