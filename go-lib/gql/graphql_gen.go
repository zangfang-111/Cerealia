// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"time"

	"bitbucket.org/cerealia/apps/go-lib/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AccessApproval() AccessApprovalResolver
	ApproveReq() ApproveReqResolver
	Doc() DocResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Query() QueryResolver
	StageModerator() StageModeratorResolver
	Trade() TradeResolver
	TradeOffer() TradeOfferResolver
	TradeStageAddReq() TradeStageAddReqResolver
	TradeStageDoc() TradeStageDocResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AccessApproval struct {
		Approver  func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Reason    func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	AdminUser struct {
		Approvals func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ApproveReq struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		ApprovedTx   func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqActor     func(childComplexity int) int
		ReqAt        func(childComplexity int) int
		ReqBy        func(childComplexity int) int
		ReqReason    func(childComplexity int) int
		ReqTx        func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	AuthUser struct {
		ID    func(childComplexity int) int
		Token func(childComplexity int) int
	}

	Doc struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Hash      func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Note      func(childComplexity int) int
		Type      func(childComplexity int) int
		URL       func(childComplexity int) int
	}

	Mutation struct {
		AdminApproveUser          func(childComplexity int, id string, status model.SimpleApproval, reason *string) int
		MkTradeCloseTx            func(childComplexity int, id string, operationType model.Approval) int
		MkTradeStageAddTx         func(childComplexity int, id model.TradeStagePath, operationType model.Approval) int
		MkTradeStageCloseTx       func(childComplexity int, id model.TradeStagePath, operationType model.Approval) int
		MkTradeStageDocTx         func(childComplexity int, id model.TradeStageDocPath, operationType model.Approval, expiresAt *time.Time) int
		NotificationDismiss       func(childComplexity int, id string) int
		OrganizationCreate        func(childComplexity int, input model.OrgInput) int
		TradeCloseReq             func(childComplexity int, id string, reason string, signedTx string) int
		TradeCloseReqApprove      func(childComplexity int, id string, signedTx string) int
		TradeCloseReqReject       func(childComplexity int, id string, reason string, signedTx string) int
		TradeCreate               func(childComplexity int, input model.NewTradeInput) int
		TradeOfferClose           func(childComplexity int, id string) int
		TradeOfferCreate          func(childComplexity int, input model.TradeOfferInput) int
		TradeStageAddReq          func(childComplexity int, input model.NewStageInput, signedTx string, withApproval bool) int
		TradeStageAddReqApprove   func(childComplexity int, id model.TradeStagePath, signedTx string) int
		TradeStageAddReqReject    func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageCloseReq        func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageCloseReqApprove func(childComplexity int, id model.TradeStagePath, signedTx string) int
		TradeStageCloseReqReject  func(childComplexity int, id model.TradeStagePath, signedTx string, reason string) int
		TradeStageDelReq          func(childComplexity int, id model.TradeStagePath, reason string) int
		TradeStageDelReqApprove   func(childComplexity int, id model.TradeStagePath) int
		TradeStageDelReqReject    func(childComplexity int, id model.TradeStagePath, reason string) int
		TradeStageDocApprove      func(childComplexity int, id model.TradeStageDocPath, signedTx string) int
		TradeStageDocReject       func(childComplexity int, id model.TradeStageDocPath, signedTx string, reason string) int
		TradeStageSetExpireTime   func(childComplexity int, id model.TradeStagePath, expiresAt string) int
		UserEmailChange           func(childComplexity int, input []string) int
		UserLogin                 func(childComplexity int, input model.UserLoginInput) int
		UserPasswordChange        func(childComplexity int, input model.ChangePasswordInput) int
		UserProfileUpdate         func(childComplexity int, input model.UserProfileInput) int
		UserSignup                func(childComplexity int, input *model.NewUserInput) int
	}

	Notification struct {
		Action      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Dismissed   func(childComplexity int) int
		EntityID    func(childComplexity int) int
		ID          func(childComplexity int) int
		Msg         func(childComplexity int) int
		Receiver    func(childComplexity int) int
		TriggeredBy func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Organization struct {
		Address   func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Telephone func(childComplexity int) int
	}

	Query struct {
		AdminTrades        func(childComplexity int) int
		AdminUsers         func(childComplexity int) int
		Notifications      func(childComplexity int, from uint) int
		NotificationsTrade func(childComplexity int, id string) int
		Organizations      func(childComplexity int) int
		StellarNet         func(childComplexity int) int
		Trade              func(childComplexity int, id string) int
		TradeOffer         func(childComplexity int, id string) int
		TradeOffers        func(childComplexity int) int
		TradeTemplates     func(childComplexity int) int
		Trades             func(childComplexity int) int
		User               func(childComplexity int, id *string) int
		Users              func(childComplexity int) int
	}

	StageModerator struct {
		CreatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	StellarNet struct {
		Name       func(childComplexity int) int
		Passphrase func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	Trade struct {
		ActorWallet  func(childComplexity int) int
		Buyer        func(childComplexity int) int
		CloseReqs    func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Moderating   func(childComplexity int) int
		Name         func(childComplexity int) int
		ScAddr       func(childComplexity int) int
		Seller       func(childComplexity int) int
		StageAddReqs func(childComplexity int) int
		Stages       func(childComplexity int) int
		Template     func(childComplexity int) int
		TradeOffer   func(childComplexity int) int
	}

	TradeActorWallet struct {
		KeyPath  func(childComplexity int) int
		PubKey   func(childComplexity int) int
		WalletID func(childComplexity int) int
	}

	TradeOffer struct {
		ClosedAt    func(childComplexity int) int
		ComType     func(childComplexity int) int
		Commodity   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Currency    func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Incoterm    func(childComplexity int) int
		IsAnonymous func(childComplexity int) int
		IsSell      func(childComplexity int) int
		MarketLoc   func(childComplexity int) int
		Note        func(childComplexity int) int
		Org         func(childComplexity int) int
		Origin      func(childComplexity int) int
		Price       func(childComplexity int) int
		PriceType   func(childComplexity int) int
		Quality     func(childComplexity int) int
		Shipment    func(childComplexity int) int
		Terms       func(childComplexity int) int
		Vol         func(childComplexity int) int
	}

	TradeStage struct {
		AddReqIdx   func(childComplexity int) int
		CloseReqs   func(childComplexity int) int
		DelReqs     func(childComplexity int) int
		Description func(childComplexity int) int
		Docs        func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		Moderator   func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
	}

	TradeStageAddReq struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		Description  func(childComplexity int) int
		Name         func(childComplexity int) int
		Owner        func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqActor     func(childComplexity int) int
		ReqAt        func(childComplexity int) int
		ReqBy        func(childComplexity int) int
		ReqReason    func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	TradeStageDoc struct {
		ApprovedAt   func(childComplexity int) int
		ApprovedBy   func(childComplexity int) int
		ApprovedTx   func(childComplexity int) int
		Doc          func(childComplexity int) int
		ExpiresAt    func(childComplexity int) int
		RejectReason func(childComplexity int) int
		ReqTx        func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	TradeStageTemplate struct {
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
	}

	TradeTemplate struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Stages      func(childComplexity int) int
	}

	User struct {
		Avatar    func(childComplexity int) int
		Biography func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Emails    func(childComplexity int) int
		FirstName func(childComplexity int) int
		ID        func(childComplexity int) int
		LastName  func(childComplexity int) int
		OrgMap    func(childComplexity int) int
		PubKey    func(childComplexity int) int
		Roles     func(childComplexity int) int
	}

	UserOrgMap struct {
		Org  func(childComplexity int) int
		Role func(childComplexity int) int
	}
}

type AccessApprovalResolver interface {
	Approver(ctx context.Context, obj *model.AccessApproval) (*model.User, error)
}
type ApproveReqResolver interface {
	ReqBy(ctx context.Context, obj *model.ApproveReq) (*model.User, error)

	ApprovedBy(ctx context.Context, obj *model.ApproveReq) (*model.User, error)
}
type DocResolver interface {
	CreatedBy(ctx context.Context, obj *model.Doc) (*model.User, error)
}
type MutationResolver interface {
	UserSignup(ctx context.Context, input *model.NewUserInput) (*int, error)
	UserLogin(ctx context.Context, input model.UserLoginInput) (*model.AuthUser, error)
	UserPasswordChange(ctx context.Context, input model.ChangePasswordInput) (*int, error)
	UserEmailChange(ctx context.Context, input []string) (*int, error)
	UserProfileUpdate(ctx context.Context, input model.UserProfileInput) (*model.User, error)
	OrganizationCreate(ctx context.Context, input model.OrgInput) (*model.Organization, error)
	TradeCreate(ctx context.Context, input model.NewTradeInput) (*model.Trade, error)
	TradeStageAddReq(ctx context.Context, input model.NewStageInput, signedTx string, withApproval bool) (*model.TradeStageAddReq, error)
	TradeStageAddReqApprove(ctx context.Context, id model.TradeStagePath, signedTx string) (*model.TradeStage, error)
	TradeStageAddReqReject(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*int, error)
	TradeStageDelReq(ctx context.Context, id model.TradeStagePath, reason string) (*model.ApproveReq, error)
	TradeStageDelReqApprove(ctx context.Context, id model.TradeStagePath) (*model.ApproveReq, error)
	TradeStageDelReqReject(ctx context.Context, id model.TradeStagePath, reason string) (*int, error)
	TradeStageCloseReq(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*model.ApproveReq, error)
	TradeStageCloseReqApprove(ctx context.Context, id model.TradeStagePath, signedTx string) (*model.ApproveReq, error)
	TradeStageCloseReqReject(ctx context.Context, id model.TradeStagePath, signedTx string, reason string) (*int, error)
	TradeStageSetExpireTime(ctx context.Context, id model.TradeStagePath, expiresAt string) (*int, error)
	TradeCloseReq(ctx context.Context, id string, reason string, signedTx string) (*model.ApproveReq, error)
	TradeCloseReqApprove(ctx context.Context, id string, signedTx string) (*model.ApproveReq, error)
	TradeCloseReqReject(ctx context.Context, id string, reason string, signedTx string) (*int, error)
	TradeStageDocApprove(ctx context.Context, id model.TradeStageDocPath, signedTx string) (*model.TradeStageDoc, error)
	TradeStageDocReject(ctx context.Context, id model.TradeStageDocPath, signedTx string, reason string) (*int, error)
	TradeOfferCreate(ctx context.Context, input model.TradeOfferInput) (*model.TradeOffer, error)
	TradeOfferClose(ctx context.Context, id string) (*int, error)
	NotificationDismiss(ctx context.Context, id string) (*int, error)
	MkTradeStageDocTx(ctx context.Context, id model.TradeStageDocPath, operationType model.Approval, expiresAt *time.Time) (string, error)
	MkTradeStageCloseTx(ctx context.Context, id model.TradeStagePath, operationType model.Approval) (string, error)
	MkTradeStageAddTx(ctx context.Context, id model.TradeStagePath, operationType model.Approval) (string, error)
	MkTradeCloseTx(ctx context.Context, id string, operationType model.Approval) (string, error)
	AdminApproveUser(ctx context.Context, id string, status model.SimpleApproval, reason *string) (*model.AccessApproval, error)
}
type NotificationResolver interface {
	TriggeredBy(ctx context.Context, obj *model.Notification) (*model.User, error)
}
type QueryResolver interface {
	User(ctx context.Context, id *string) (*model.User, error)
	Users(ctx context.Context) ([]model.User, error)
	Organizations(ctx context.Context) ([]model.Organization, error)
	AdminUsers(ctx context.Context) ([]model.AdminUser, error)
	TradeTemplates(ctx context.Context) ([]model.TradeTemplate, error)
	Trade(ctx context.Context, id string) (*model.Trade, error)
	Trades(ctx context.Context) ([]model.Trade, error)
	TradeOffer(ctx context.Context, id string) (*model.TradeOffer, error)
	TradeOffers(ctx context.Context) ([]model.TradeOffer, error)
	Notifications(ctx context.Context, from uint) ([]model.Notification, error)
	NotificationsTrade(ctx context.Context, id string) ([]model.Notification, error)
	StellarNet(ctx context.Context) (*model.StellarNet, error)
	AdminTrades(ctx context.Context) ([]model.Trade, error)
}
type StageModeratorResolver interface {
	User(ctx context.Context, obj *model.StageModerator) (*model.User, error)
}
type TradeResolver interface {
	Template(ctx context.Context, obj *model.Trade) (*model.TradeTemplate, error)
	Buyer(ctx context.Context, obj *model.Trade) (*model.User, error)
	Seller(ctx context.Context, obj *model.Trade) (*model.User, error)
	ScAddr(ctx context.Context, obj *model.Trade) (string, error)

	CreatedBy(ctx context.Context, obj *model.Trade) (*model.User, error)

	TradeOffer(ctx context.Context, obj *model.Trade) (*model.TradeOffer, error)

	ActorWallet(ctx context.Context, obj *model.Trade) (*model.TradeActorWallet, error)
}
type TradeOfferResolver interface {
	CreatedBy(ctx context.Context, obj *model.TradeOffer) (*model.User, error)

	Org(ctx context.Context, obj *model.TradeOffer) (*model.Organization, error)

	Terms(ctx context.Context, obj *model.TradeOffer) (*model.Doc, error)
}
type TradeStageAddReqResolver interface {
	ReqBy(ctx context.Context, obj *model.TradeStageAddReq) (*model.User, error)

	ApprovedBy(ctx context.Context, obj *model.TradeStageAddReq) (*model.User, error)
}
type TradeStageDocResolver interface {
	Doc(ctx context.Context, obj *model.TradeStageDoc) (*model.Doc, error)

	ApprovedBy(ctx context.Context, obj *model.TradeStageDoc) (*model.User, error)
}
type UserResolver interface {
	OrgMap(ctx context.Context, obj *model.User) ([]model.UserOrgMap, error)

	PubKey(ctx context.Context, obj *model.User) (*string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AccessApproval.Approver":
		if e.complexity.AccessApproval.Approver == nil {
			break
		}

		return e.complexity.AccessApproval.Approver(childComplexity), true

	case "AccessApproval.CreatedAt":
		if e.complexity.AccessApproval.CreatedAt == nil {
			break
		}

		return e.complexity.AccessApproval.CreatedAt(childComplexity), true

	case "AccessApproval.Reason":
		if e.complexity.AccessApproval.Reason == nil {
			break
		}

		return e.complexity.AccessApproval.Reason(childComplexity), true

	case "AccessApproval.Status":
		if e.complexity.AccessApproval.Status == nil {
			break
		}

		return e.complexity.AccessApproval.Status(childComplexity), true

	case "AdminUser.Approvals":
		if e.complexity.AdminUser.Approvals == nil {
			break
		}

		return e.complexity.AdminUser.Approvals(childComplexity), true

	case "AdminUser.User":
		if e.complexity.AdminUser.User == nil {
			break
		}

		return e.complexity.AdminUser.User(childComplexity), true

	case "ApproveReq.ApprovedAt":
		if e.complexity.ApproveReq.ApprovedAt == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedAt(childComplexity), true

	case "ApproveReq.ApprovedBy":
		if e.complexity.ApproveReq.ApprovedBy == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedBy(childComplexity), true

	case "ApproveReq.ApprovedTx":
		if e.complexity.ApproveReq.ApprovedTx == nil {
			break
		}

		return e.complexity.ApproveReq.ApprovedTx(childComplexity), true

	case "ApproveReq.RejectReason":
		if e.complexity.ApproveReq.RejectReason == nil {
			break
		}

		return e.complexity.ApproveReq.RejectReason(childComplexity), true

	case "ApproveReq.ReqActor":
		if e.complexity.ApproveReq.ReqActor == nil {
			break
		}

		return e.complexity.ApproveReq.ReqActor(childComplexity), true

	case "ApproveReq.ReqAt":
		if e.complexity.ApproveReq.ReqAt == nil {
			break
		}

		return e.complexity.ApproveReq.ReqAt(childComplexity), true

	case "ApproveReq.ReqBy":
		if e.complexity.ApproveReq.ReqBy == nil {
			break
		}

		return e.complexity.ApproveReq.ReqBy(childComplexity), true

	case "ApproveReq.ReqReason":
		if e.complexity.ApproveReq.ReqReason == nil {
			break
		}

		return e.complexity.ApproveReq.ReqReason(childComplexity), true

	case "ApproveReq.ReqTx":
		if e.complexity.ApproveReq.ReqTx == nil {
			break
		}

		return e.complexity.ApproveReq.ReqTx(childComplexity), true

	case "ApproveReq.Status":
		if e.complexity.ApproveReq.Status == nil {
			break
		}

		return e.complexity.ApproveReq.Status(childComplexity), true

	case "AuthUser.ID":
		if e.complexity.AuthUser.ID == nil {
			break
		}

		return e.complexity.AuthUser.ID(childComplexity), true

	case "AuthUser.Token":
		if e.complexity.AuthUser.Token == nil {
			break
		}

		return e.complexity.AuthUser.Token(childComplexity), true

	case "Doc.CreatedAt":
		if e.complexity.Doc.CreatedAt == nil {
			break
		}

		return e.complexity.Doc.CreatedAt(childComplexity), true

	case "Doc.CreatedBy":
		if e.complexity.Doc.CreatedBy == nil {
			break
		}

		return e.complexity.Doc.CreatedBy(childComplexity), true

	case "Doc.Hash":
		if e.complexity.Doc.Hash == nil {
			break
		}

		return e.complexity.Doc.Hash(childComplexity), true

	case "Doc.ID":
		if e.complexity.Doc.ID == nil {
			break
		}

		return e.complexity.Doc.ID(childComplexity), true

	case "Doc.Name":
		if e.complexity.Doc.Name == nil {
			break
		}

		return e.complexity.Doc.Name(childComplexity), true

	case "Doc.Note":
		if e.complexity.Doc.Note == nil {
			break
		}

		return e.complexity.Doc.Note(childComplexity), true

	case "Doc.Type":
		if e.complexity.Doc.Type == nil {
			break
		}

		return e.complexity.Doc.Type(childComplexity), true

	case "Doc.URL":
		if e.complexity.Doc.URL == nil {
			break
		}

		return e.complexity.Doc.URL(childComplexity), true

	case "Mutation.AdminApproveUser":
		if e.complexity.Mutation.AdminApproveUser == nil {
			break
		}

		args, err := ec.field_Mutation_adminApproveUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminApproveUser(childComplexity, args["id"].(string), args["status"].(model.SimpleApproval), args["reason"].(*string)), true

	case "Mutation.MkTradeCloseTx":
		if e.complexity.Mutation.MkTradeCloseTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeCloseTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeCloseTx(childComplexity, args["id"].(string), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageAddTx":
		if e.complexity.Mutation.MkTradeStageAddTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageAddTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageAddTx(childComplexity, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageCloseTx":
		if e.complexity.Mutation.MkTradeStageCloseTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageCloseTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageCloseTx(childComplexity, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval)), true

	case "Mutation.MkTradeStageDocTx":
		if e.complexity.Mutation.MkTradeStageDocTx == nil {
			break
		}

		args, err := ec.field_Mutation_mkTradeStageDocTx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkTradeStageDocTx(childComplexity, args["id"].(model.TradeStageDocPath), args["operationType"].(model.Approval), args["expiresAt"].(*time.Time)), true

	case "Mutation.NotificationDismiss":
		if e.complexity.Mutation.NotificationDismiss == nil {
			break
		}

		args, err := ec.field_Mutation_notificationDismiss_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NotificationDismiss(childComplexity, args["id"].(string)), true

	case "Mutation.OrganizationCreate":
		if e.complexity.Mutation.OrganizationCreate == nil {
			break
		}

		args, err := ec.field_Mutation_organizationCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OrganizationCreate(childComplexity, args["input"].(model.OrgInput)), true

	case "Mutation.TradeCloseReq":
		if e.complexity.Mutation.TradeCloseReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReq(childComplexity, args["id"].(string), args["reason"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCloseReqApprove":
		if e.complexity.Mutation.TradeCloseReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReqApprove(childComplexity, args["id"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCloseReqReject":
		if e.complexity.Mutation.TradeCloseReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCloseReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCloseReqReject(childComplexity, args["id"].(string), args["reason"].(string), args["signedTx"].(string)), true

	case "Mutation.TradeCreate":
		if e.complexity.Mutation.TradeCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tradeCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeCreate(childComplexity, args["input"].(model.NewTradeInput)), true

	case "Mutation.TradeOfferClose":
		if e.complexity.Mutation.TradeOfferClose == nil {
			break
		}

		args, err := ec.field_Mutation_tradeOfferClose_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeOfferClose(childComplexity, args["id"].(string)), true

	case "Mutation.TradeOfferCreate":
		if e.complexity.Mutation.TradeOfferCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tradeOfferCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeOfferCreate(childComplexity, args["input"].(model.TradeOfferInput)), true

	case "Mutation.TradeStageAddReq":
		if e.complexity.Mutation.TradeStageAddReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReq(childComplexity, args["input"].(model.NewStageInput), args["signedTx"].(string), args["withApproval"].(bool)), true

	case "Mutation.TradeStageAddReqApprove":
		if e.complexity.Mutation.TradeStageAddReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReqApprove(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string)), true

	case "Mutation.TradeStageAddReqReject":
		if e.complexity.Mutation.TradeStageAddReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageAddReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageAddReqReject(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageCloseReq":
		if e.complexity.Mutation.TradeStageCloseReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReq(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageCloseReqApprove":
		if e.complexity.Mutation.TradeStageCloseReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReqApprove(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string)), true

	case "Mutation.TradeStageCloseReqReject":
		if e.complexity.Mutation.TradeStageCloseReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageCloseReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageCloseReqReject(childComplexity, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageDelReq":
		if e.complexity.Mutation.TradeStageDelReq == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReq_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReq(childComplexity, args["id"].(model.TradeStagePath), args["reason"].(string)), true

	case "Mutation.TradeStageDelReqApprove":
		if e.complexity.Mutation.TradeStageDelReqApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReqApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReqApprove(childComplexity, args["id"].(model.TradeStagePath)), true

	case "Mutation.TradeStageDelReqReject":
		if e.complexity.Mutation.TradeStageDelReqReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDelReqReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDelReqReject(childComplexity, args["id"].(model.TradeStagePath), args["reason"].(string)), true

	case "Mutation.TradeStageDocApprove":
		if e.complexity.Mutation.TradeStageDocApprove == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDocApprove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDocApprove(childComplexity, args["id"].(model.TradeStageDocPath), args["signedTx"].(string)), true

	case "Mutation.TradeStageDocReject":
		if e.complexity.Mutation.TradeStageDocReject == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageDocReject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageDocReject(childComplexity, args["id"].(model.TradeStageDocPath), args["signedTx"].(string), args["reason"].(string)), true

	case "Mutation.TradeStageSetExpireTime":
		if e.complexity.Mutation.TradeStageSetExpireTime == nil {
			break
		}

		args, err := ec.field_Mutation_tradeStageSetExpireTime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TradeStageSetExpireTime(childComplexity, args["id"].(model.TradeStagePath), args["expiresAt"].(string)), true

	case "Mutation.UserEmailChange":
		if e.complexity.Mutation.UserEmailChange == nil {
			break
		}

		args, err := ec.field_Mutation_userEmailChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserEmailChange(childComplexity, args["input"].([]string)), true

	case "Mutation.UserLogin":
		if e.complexity.Mutation.UserLogin == nil {
			break
		}

		args, err := ec.field_Mutation_userLogin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserLogin(childComplexity, args["input"].(model.UserLoginInput)), true

	case "Mutation.UserPasswordChange":
		if e.complexity.Mutation.UserPasswordChange == nil {
			break
		}

		args, err := ec.field_Mutation_userPasswordChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserPasswordChange(childComplexity, args["input"].(model.ChangePasswordInput)), true

	case "Mutation.UserProfileUpdate":
		if e.complexity.Mutation.UserProfileUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_userProfileUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserProfileUpdate(childComplexity, args["input"].(model.UserProfileInput)), true

	case "Mutation.UserSignup":
		if e.complexity.Mutation.UserSignup == nil {
			break
		}

		args, err := ec.field_Mutation_userSignup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserSignup(childComplexity, args["input"].(*model.NewUserInput)), true

	case "Notification.Action":
		if e.complexity.Notification.Action == nil {
			break
		}

		return e.complexity.Notification.Action(childComplexity), true

	case "Notification.CreatedAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.Dismissed":
		if e.complexity.Notification.Dismissed == nil {
			break
		}

		return e.complexity.Notification.Dismissed(childComplexity), true

	case "Notification.EntityID":
		if e.complexity.Notification.EntityID == nil {
			break
		}

		return e.complexity.Notification.EntityID(childComplexity), true

	case "Notification.ID":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.Msg":
		if e.complexity.Notification.Msg == nil {
			break
		}

		return e.complexity.Notification.Msg(childComplexity), true

	case "Notification.Receiver":
		if e.complexity.Notification.Receiver == nil {
			break
		}

		return e.complexity.Notification.Receiver(childComplexity), true

	case "Notification.TriggeredBy":
		if e.complexity.Notification.TriggeredBy == nil {
			break
		}

		return e.complexity.Notification.TriggeredBy(childComplexity), true

	case "Notification.Type":
		if e.complexity.Notification.Type == nil {
			break
		}

		return e.complexity.Notification.Type(childComplexity), true

	case "Organization.Address":
		if e.complexity.Organization.Address == nil {
			break
		}

		return e.complexity.Organization.Address(childComplexity), true

	case "Organization.Email":
		if e.complexity.Organization.Email == nil {
			break
		}

		return e.complexity.Organization.Email(childComplexity), true

	case "Organization.ID":
		if e.complexity.Organization.ID == nil {
			break
		}

		return e.complexity.Organization.ID(childComplexity), true

	case "Organization.Name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.Telephone":
		if e.complexity.Organization.Telephone == nil {
			break
		}

		return e.complexity.Organization.Telephone(childComplexity), true

	case "Query.AdminTrades":
		if e.complexity.Query.AdminTrades == nil {
			break
		}

		return e.complexity.Query.AdminTrades(childComplexity), true

	case "Query.AdminUsers":
		if e.complexity.Query.AdminUsers == nil {
			break
		}

		return e.complexity.Query.AdminUsers(childComplexity), true

	case "Query.Notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["from"].(uint)), true

	case "Query.NotificationsTrade":
		if e.complexity.Query.NotificationsTrade == nil {
			break
		}

		args, err := ec.field_Query_notificationsTrade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NotificationsTrade(childComplexity, args["id"].(string)), true

	case "Query.Organizations":
		if e.complexity.Query.Organizations == nil {
			break
		}

		return e.complexity.Query.Organizations(childComplexity), true

	case "Query.StellarNet":
		if e.complexity.Query.StellarNet == nil {
			break
		}

		return e.complexity.Query.StellarNet(childComplexity), true

	case "Query.Trade":
		if e.complexity.Query.Trade == nil {
			break
		}

		args, err := ec.field_Query_trade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trade(childComplexity, args["id"].(string)), true

	case "Query.TradeOffer":
		if e.complexity.Query.TradeOffer == nil {
			break
		}

		args, err := ec.field_Query_tradeOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TradeOffer(childComplexity, args["id"].(string)), true

	case "Query.TradeOffers":
		if e.complexity.Query.TradeOffers == nil {
			break
		}

		return e.complexity.Query.TradeOffers(childComplexity), true

	case "Query.TradeTemplates":
		if e.complexity.Query.TradeTemplates == nil {
			break
		}

		return e.complexity.Query.TradeTemplates(childComplexity), true

	case "Query.Trades":
		if e.complexity.Query.Trades == nil {
			break
		}

		return e.complexity.Query.Trades(childComplexity), true

	case "Query.User":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(*string)), true

	case "Query.Users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "StageModerator.CreatedAt":
		if e.complexity.StageModerator.CreatedAt == nil {
			break
		}

		return e.complexity.StageModerator.CreatedAt(childComplexity), true

	case "StageModerator.User":
		if e.complexity.StageModerator.User == nil {
			break
		}

		return e.complexity.StageModerator.User(childComplexity), true

	case "StellarNet.Name":
		if e.complexity.StellarNet.Name == nil {
			break
		}

		return e.complexity.StellarNet.Name(childComplexity), true

	case "StellarNet.Passphrase":
		if e.complexity.StellarNet.Passphrase == nil {
			break
		}

		return e.complexity.StellarNet.Passphrase(childComplexity), true

	case "StellarNet.URL":
		if e.complexity.StellarNet.URL == nil {
			break
		}

		return e.complexity.StellarNet.URL(childComplexity), true

	case "Trade.ActorWallet":
		if e.complexity.Trade.ActorWallet == nil {
			break
		}

		return e.complexity.Trade.ActorWallet(childComplexity), true

	case "Trade.Buyer":
		if e.complexity.Trade.Buyer == nil {
			break
		}

		return e.complexity.Trade.Buyer(childComplexity), true

	case "Trade.CloseReqs":
		if e.complexity.Trade.CloseReqs == nil {
			break
		}

		return e.complexity.Trade.CloseReqs(childComplexity), true

	case "Trade.CreatedAt":
		if e.complexity.Trade.CreatedAt == nil {
			break
		}

		return e.complexity.Trade.CreatedAt(childComplexity), true

	case "Trade.CreatedBy":
		if e.complexity.Trade.CreatedBy == nil {
			break
		}

		return e.complexity.Trade.CreatedBy(childComplexity), true

	case "Trade.Description":
		if e.complexity.Trade.Description == nil {
			break
		}

		return e.complexity.Trade.Description(childComplexity), true

	case "Trade.ID":
		if e.complexity.Trade.ID == nil {
			break
		}

		return e.complexity.Trade.ID(childComplexity), true

	case "Trade.Moderating":
		if e.complexity.Trade.Moderating == nil {
			break
		}

		return e.complexity.Trade.Moderating(childComplexity), true

	case "Trade.Name":
		if e.complexity.Trade.Name == nil {
			break
		}

		return e.complexity.Trade.Name(childComplexity), true

	case "Trade.ScAddr":
		if e.complexity.Trade.ScAddr == nil {
			break
		}

		return e.complexity.Trade.ScAddr(childComplexity), true

	case "Trade.Seller":
		if e.complexity.Trade.Seller == nil {
			break
		}

		return e.complexity.Trade.Seller(childComplexity), true

	case "Trade.StageAddReqs":
		if e.complexity.Trade.StageAddReqs == nil {
			break
		}

		return e.complexity.Trade.StageAddReqs(childComplexity), true

	case "Trade.Stages":
		if e.complexity.Trade.Stages == nil {
			break
		}

		return e.complexity.Trade.Stages(childComplexity), true

	case "Trade.Template":
		if e.complexity.Trade.Template == nil {
			break
		}

		return e.complexity.Trade.Template(childComplexity), true

	case "Trade.TradeOffer":
		if e.complexity.Trade.TradeOffer == nil {
			break
		}

		return e.complexity.Trade.TradeOffer(childComplexity), true

	case "TradeActorWallet.KeyPath":
		if e.complexity.TradeActorWallet.KeyPath == nil {
			break
		}

		return e.complexity.TradeActorWallet.KeyPath(childComplexity), true

	case "TradeActorWallet.PubKey":
		if e.complexity.TradeActorWallet.PubKey == nil {
			break
		}

		return e.complexity.TradeActorWallet.PubKey(childComplexity), true

	case "TradeActorWallet.WalletID":
		if e.complexity.TradeActorWallet.WalletID == nil {
			break
		}

		return e.complexity.TradeActorWallet.WalletID(childComplexity), true

	case "TradeOffer.ClosedAt":
		if e.complexity.TradeOffer.ClosedAt == nil {
			break
		}

		return e.complexity.TradeOffer.ClosedAt(childComplexity), true

	case "TradeOffer.ComType":
		if e.complexity.TradeOffer.ComType == nil {
			break
		}

		return e.complexity.TradeOffer.ComType(childComplexity), true

	case "TradeOffer.Commodity":
		if e.complexity.TradeOffer.Commodity == nil {
			break
		}

		return e.complexity.TradeOffer.Commodity(childComplexity), true

	case "TradeOffer.CreatedAt":
		if e.complexity.TradeOffer.CreatedAt == nil {
			break
		}

		return e.complexity.TradeOffer.CreatedAt(childComplexity), true

	case "TradeOffer.CreatedBy":
		if e.complexity.TradeOffer.CreatedBy == nil {
			break
		}

		return e.complexity.TradeOffer.CreatedBy(childComplexity), true

	case "TradeOffer.Currency":
		if e.complexity.TradeOffer.Currency == nil {
			break
		}

		return e.complexity.TradeOffer.Currency(childComplexity), true

	case "TradeOffer.ExpiresAt":
		if e.complexity.TradeOffer.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeOffer.ExpiresAt(childComplexity), true

	case "TradeOffer.ID":
		if e.complexity.TradeOffer.ID == nil {
			break
		}

		return e.complexity.TradeOffer.ID(childComplexity), true

	case "TradeOffer.Incoterm":
		if e.complexity.TradeOffer.Incoterm == nil {
			break
		}

		return e.complexity.TradeOffer.Incoterm(childComplexity), true

	case "TradeOffer.IsAnonymous":
		if e.complexity.TradeOffer.IsAnonymous == nil {
			break
		}

		return e.complexity.TradeOffer.IsAnonymous(childComplexity), true

	case "TradeOffer.IsSell":
		if e.complexity.TradeOffer.IsSell == nil {
			break
		}

		return e.complexity.TradeOffer.IsSell(childComplexity), true

	case "TradeOffer.MarketLoc":
		if e.complexity.TradeOffer.MarketLoc == nil {
			break
		}

		return e.complexity.TradeOffer.MarketLoc(childComplexity), true

	case "TradeOffer.Note":
		if e.complexity.TradeOffer.Note == nil {
			break
		}

		return e.complexity.TradeOffer.Note(childComplexity), true

	case "TradeOffer.Org":
		if e.complexity.TradeOffer.Org == nil {
			break
		}

		return e.complexity.TradeOffer.Org(childComplexity), true

	case "TradeOffer.Origin":
		if e.complexity.TradeOffer.Origin == nil {
			break
		}

		return e.complexity.TradeOffer.Origin(childComplexity), true

	case "TradeOffer.Price":
		if e.complexity.TradeOffer.Price == nil {
			break
		}

		return e.complexity.TradeOffer.Price(childComplexity), true

	case "TradeOffer.PriceType":
		if e.complexity.TradeOffer.PriceType == nil {
			break
		}

		return e.complexity.TradeOffer.PriceType(childComplexity), true

	case "TradeOffer.Quality":
		if e.complexity.TradeOffer.Quality == nil {
			break
		}

		return e.complexity.TradeOffer.Quality(childComplexity), true

	case "TradeOffer.Shipment":
		if e.complexity.TradeOffer.Shipment == nil {
			break
		}

		return e.complexity.TradeOffer.Shipment(childComplexity), true

	case "TradeOffer.Terms":
		if e.complexity.TradeOffer.Terms == nil {
			break
		}

		return e.complexity.TradeOffer.Terms(childComplexity), true

	case "TradeOffer.Vol":
		if e.complexity.TradeOffer.Vol == nil {
			break
		}

		return e.complexity.TradeOffer.Vol(childComplexity), true

	case "TradeStage.AddReqIdx":
		if e.complexity.TradeStage.AddReqIdx == nil {
			break
		}

		return e.complexity.TradeStage.AddReqIdx(childComplexity), true

	case "TradeStage.CloseReqs":
		if e.complexity.TradeStage.CloseReqs == nil {
			break
		}

		return e.complexity.TradeStage.CloseReqs(childComplexity), true

	case "TradeStage.DelReqs":
		if e.complexity.TradeStage.DelReqs == nil {
			break
		}

		return e.complexity.TradeStage.DelReqs(childComplexity), true

	case "TradeStage.Description":
		if e.complexity.TradeStage.Description == nil {
			break
		}

		return e.complexity.TradeStage.Description(childComplexity), true

	case "TradeStage.Docs":
		if e.complexity.TradeStage.Docs == nil {
			break
		}

		return e.complexity.TradeStage.Docs(childComplexity), true

	case "TradeStage.ExpiresAt":
		if e.complexity.TradeStage.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeStage.ExpiresAt(childComplexity), true

	case "TradeStage.Moderator":
		if e.complexity.TradeStage.Moderator == nil {
			break
		}

		return e.complexity.TradeStage.Moderator(childComplexity), true

	case "TradeStage.Name":
		if e.complexity.TradeStage.Name == nil {
			break
		}

		return e.complexity.TradeStage.Name(childComplexity), true

	case "TradeStage.Owner":
		if e.complexity.TradeStage.Owner == nil {
			break
		}

		return e.complexity.TradeStage.Owner(childComplexity), true

	case "TradeStageAddReq.ApprovedAt":
		if e.complexity.TradeStageAddReq.ApprovedAt == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ApprovedAt(childComplexity), true

	case "TradeStageAddReq.ApprovedBy":
		if e.complexity.TradeStageAddReq.ApprovedBy == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ApprovedBy(childComplexity), true

	case "TradeStageAddReq.Description":
		if e.complexity.TradeStageAddReq.Description == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Description(childComplexity), true

	case "TradeStageAddReq.Name":
		if e.complexity.TradeStageAddReq.Name == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Name(childComplexity), true

	case "TradeStageAddReq.Owner":
		if e.complexity.TradeStageAddReq.Owner == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Owner(childComplexity), true

	case "TradeStageAddReq.RejectReason":
		if e.complexity.TradeStageAddReq.RejectReason == nil {
			break
		}

		return e.complexity.TradeStageAddReq.RejectReason(childComplexity), true

	case "TradeStageAddReq.ReqActor":
		if e.complexity.TradeStageAddReq.ReqActor == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqActor(childComplexity), true

	case "TradeStageAddReq.ReqAt":
		if e.complexity.TradeStageAddReq.ReqAt == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqAt(childComplexity), true

	case "TradeStageAddReq.ReqBy":
		if e.complexity.TradeStageAddReq.ReqBy == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqBy(childComplexity), true

	case "TradeStageAddReq.ReqReason":
		if e.complexity.TradeStageAddReq.ReqReason == nil {
			break
		}

		return e.complexity.TradeStageAddReq.ReqReason(childComplexity), true

	case "TradeStageAddReq.Status":
		if e.complexity.TradeStageAddReq.Status == nil {
			break
		}

		return e.complexity.TradeStageAddReq.Status(childComplexity), true

	case "TradeStageDoc.ApprovedAt":
		if e.complexity.TradeStageDoc.ApprovedAt == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedAt(childComplexity), true

	case "TradeStageDoc.ApprovedBy":
		if e.complexity.TradeStageDoc.ApprovedBy == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedBy(childComplexity), true

	case "TradeStageDoc.ApprovedTx":
		if e.complexity.TradeStageDoc.ApprovedTx == nil {
			break
		}

		return e.complexity.TradeStageDoc.ApprovedTx(childComplexity), true

	case "TradeStageDoc.Doc":
		if e.complexity.TradeStageDoc.Doc == nil {
			break
		}

		return e.complexity.TradeStageDoc.Doc(childComplexity), true

	case "TradeStageDoc.ExpiresAt":
		if e.complexity.TradeStageDoc.ExpiresAt == nil {
			break
		}

		return e.complexity.TradeStageDoc.ExpiresAt(childComplexity), true

	case "TradeStageDoc.RejectReason":
		if e.complexity.TradeStageDoc.RejectReason == nil {
			break
		}

		return e.complexity.TradeStageDoc.RejectReason(childComplexity), true

	case "TradeStageDoc.ReqTx":
		if e.complexity.TradeStageDoc.ReqTx == nil {
			break
		}

		return e.complexity.TradeStageDoc.ReqTx(childComplexity), true

	case "TradeStageDoc.Status":
		if e.complexity.TradeStageDoc.Status == nil {
			break
		}

		return e.complexity.TradeStageDoc.Status(childComplexity), true

	case "TradeStageTemplate.Description":
		if e.complexity.TradeStageTemplate.Description == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Description(childComplexity), true

	case "TradeStageTemplate.Name":
		if e.complexity.TradeStageTemplate.Name == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Name(childComplexity), true

	case "TradeStageTemplate.Owner":
		if e.complexity.TradeStageTemplate.Owner == nil {
			break
		}

		return e.complexity.TradeStageTemplate.Owner(childComplexity), true

	case "TradeTemplate.Description":
		if e.complexity.TradeTemplate.Description == nil {
			break
		}

		return e.complexity.TradeTemplate.Description(childComplexity), true

	case "TradeTemplate.ID":
		if e.complexity.TradeTemplate.ID == nil {
			break
		}

		return e.complexity.TradeTemplate.ID(childComplexity), true

	case "TradeTemplate.Name":
		if e.complexity.TradeTemplate.Name == nil {
			break
		}

		return e.complexity.TradeTemplate.Name(childComplexity), true

	case "TradeTemplate.Stages":
		if e.complexity.TradeTemplate.Stages == nil {
			break
		}

		return e.complexity.TradeTemplate.Stages(childComplexity), true

	case "User.Avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.Biography":
		if e.complexity.User.Biography == nil {
			break
		}

		return e.complexity.User.Biography(childComplexity), true

	case "User.CreatedAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.Emails":
		if e.complexity.User.Emails == nil {
			break
		}

		return e.complexity.User.Emails(childComplexity), true

	case "User.FirstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.LastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.OrgMap":
		if e.complexity.User.OrgMap == nil {
			break
		}

		return e.complexity.User.OrgMap(childComplexity), true

	case "User.PubKey":
		if e.complexity.User.PubKey == nil {
			break
		}

		return e.complexity.User.PubKey(childComplexity), true

	case "User.Roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserOrgMap.Org":
		if e.complexity.UserOrgMap.Org == nil {
			break
		}

		return e.complexity.UserOrgMap.Org(childComplexity), true

	case "UserOrgMap.Role":
		if e.complexity.UserOrgMap.Role == nil {
			break
		}

		return e.complexity.UserOrgMap.Role(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "websrv_schema.graphql", Input: `"Query defines all possible query types; Should be immutable"
type Query {
  "query single user by id; gets current user when id is null"
  user(id: ID): User
  "returns only approved users"
  users: [User!]!
  organizations: [Organization!]!
   "returns all users"
  adminUsers: [AdminUser!]!
  tradeTemplates: [TradeTemplate!]!
  trade(id: ID!): Trade
  trades: [Trade!]!

  tradeOffer(id: ID!): TradeOffer
  tradeOffers: [TradeOffer!]!
  "Retrieve current user's public key for this trade"

  notifications(from: Uint!): [Notification!]!
  notificationsTrade(id: String!): [Notification!]!

  stellarNet: StellarNet
  adminTrades: [Trade!]!
}

"""
The mutation type, represents all updates we can make to our data.
Principles:
+ Name mutation by the resource first and order them automatically
+ mutations should provide user/business-level errors via a
  userErrors field on the mutation payload
These operations change the state of the database
"""
type Mutation {
  userSignup(input: NewUserInput): Int
  userLogin(input: UserLoginInput!): AuthUser
  userPasswordChange(input: ChangePasswordInput!): Int
  userEmailChange(input: [Email!]!): Int
  userProfileUpdate(input: UserProfileInput!): User
  organizationCreate(input: OrgInput!): Organization

  tradeCreate(input: NewTradeInput!) : Trade
  tradeStageAddReq(input: NewStageInput!, signedTx: String!, withApproval: Boolean!): TradeStageAddReq
  tradeStageAddReqApprove(id: TradeStagePath!, signedTx: String!,): TradeStage
  tradeStageAddReqReject(id: TradeStagePath!, signedTx: String!, reason: String!): Int

  tradeStageDelReq(id: TradeStagePath!, reason: String!): ApproveReq
  tradeStageDelReqApprove(id: TradeStagePath!): ApproveReq
  tradeStageDelReqReject(id: TradeStagePath!, reason: String!): Int

  tradeStageCloseReq(id: TradeStagePath!, signedTx: String!, reason: String!): ApproveReq
  tradeStageCloseReqApprove(id: TradeStagePath!, signedTx: String!): ApproveReq
  tradeStageCloseReqReject(id: TradeStagePath!, signedTx: String!, reason: String!): Int
  tradeStageSetExpireTime(id: TradeStagePath!, expiresAt: String!): Int

  tradeCloseReq(id: String!, reason: String!, signedTx: String!): ApproveReq
  tradeCloseReqApprove(id: String!, signedTx: String!): ApproveReq
  tradeCloseReqReject(id: String!, reason: String!, signedTx: String!): Int

  tradeStageDocApprove(id: TradeStageDocPath!, signedTx: String!): TradeStageDoc
  tradeStageDocReject(id: TradeStageDocPath!, signedTx: String!, reason: String!): Int

  tradeOfferCreate(input: TradeOfferInput!): TradeOffer
  tradeOfferClose(id: String!): Int

  notificationDismiss(id: String!): Int

  mkTradeStageDocTx(id: TradeStageDocPath!, operationType: Approval!, expiresAt: Time): String!
  mkTradeStageCloseTx(id: TradeStagePath!, operationType: Approval!): String!
  "creates a new trade stage doc entry"
  mkTradeStageAddTx(id: TradeStagePath!, operationType: Approval!): String!
  mkTradeCloseTx(id: String!, operationType: Approval!): String!

  ### Admin mutations ###

  adminApproveUser(id: String!, status: SimpleApproval!, reason: String): AccessApproval
}

#####################
#   SCALARS

"Email field"
scalar Email
"Time field"
scalar Time
"Telephone number"
scalar Telephone
"Hash digest of file or other data. Presented as a Hex string"
scalar Hash
"Unsigned number"
scalar Uint

#####################
#   ENUMS

"Available user role options for authorization"
enum UserRole {
  "Trader is the participant of a trade. Can act on trade."
  trader
  "Moderator has supervisor privileges for trade"
  moderator
}

"Approval status of a trade or a stage"
enum Approval {
  nil
  pending
  expired
  rejected
  approved
  submitted
}

"Moderating status of a trade or a stage"
enum DoneStatus {
  nil
  doing
  done
}

"SimpleApproval is a basic status for approvals"
enum SimpleApproval {
  rejected
  approved
}

"Type of user that participates in trade"
enum TradeActor {
  "No Owner"
  n
  "Buyer"
  b
  "Seller"
  s
  "Moderator"
  m
}

"TxTradeEntity enums for transaction build"
enum TxTradeEntity {
   stage_doc
   stage_closeReqs
   stage_add
   trade_closeReqs
}

"Is it a firm offer or just a quote"
enum OfferPriceType {
  firm
  quote
}

"trading incoterm"
enum Incoterm {
  CAF
  CFR
  CFRC
  CIF
  CIFFO
  CNF
  CNFFO
  DEL
  FOB
}

enum Currency {
  USD
  RUB
  EUR
  TRY
  UAH
  CNY
}

enum NotifType {
  "triggered when a user perform some action and this triggers a notification for other users"
  action
  "triggered by a system when there is something to be do (eg documenet approval is close to expire)"
  alert
}

#####################
#   Input types

"New user input data"
input NewUserInput {
  firstName: String!
  lastName:  String!
  email:     Email!
  password:  String!
  avatar:    String
  publicKey: String!
  biography: String
  orgID:     String!
  orgRole:   String!
}

"User data for logging in"
input UserLoginInput {
  email:    Email!
  password: String!
}

"Trade creation fields"
input NewTradeInput {
  templateID:   ID!
  name:         String!
  sellerID:     ID!
  buyerID:      ID!
  description:  String
  tradeOfferID: String
}

"Context of a trade stage"
input TradeStagePath {
  tid:      ID!
  stageIdx: Uint!
}

"Context of a document"
input TradeStageDocPath {
  tid:          ID!
  stageIdx:     Uint!
  stageDocIdx:  Uint!
  stageDocHash: Hash!
}

"New trade fields"
input NewStageInput {
  tid:         ID!
  owner:       String!
  name:        String!
  description: String!
  reason:      String!
}

"Password change data"
input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

"Organization input data"
input OrgInput {
  name: String!
  address: String!
  telephone: Telephone!
  email: Email!
}

"User orgMap input"
input UserOrgMapInput {
  id:  String!
  role: String!
}

"User Profile update data"
input UserProfileInput {
  firstName: String!
  lastName:  String!
  orgMap:    [UserOrgMapInput!]
  biography: String!
}

"trade offer input data"
input TradeOfferInput {
  price:        Float!
  priceType:    OfferPriceType!
  isSell:       Boolean!
  currency:     Currency!
  expiresAt:    Time
  commodity:    String!
  comType:      [String!]!
  quality:      String!
  orgID:        String!
  origin:       String!
  isAnonymous:  Boolean!
  incoterm:     Incoterm!
  marketLoc:    String!
  vol:          Int!
  shipment:     [Time!]!
  note:         String!
  docID:        String
}

#####################
#   Resource types

"User data"
type User {
  id:        ID!
  firstName: String!
  lastName:  String!
  emails:    [Email!]
  roles:     [UserRole!]!
  avatar:    String!
  orgMap:    [UserOrgMap!]
  createdAt: Time!
  biography: String!
  pubKey:    String @deprecated
}

"AuthUser; after user login, backend sends user token"
type AuthUser {
  id:    ID!
  token: String!
}

"AdminUser; User with special Admin information"
type AdminUser {
  # ... on User
  user:       User
  approvals:   [AccessApproval!]!
}

type StageModerator {
  user:      User
  createdAt: Time
}

"User organization with role"
type UserOrgMap {
  org:  Organization!
  role: String!
}

"Organization data"
type Organization {
  id:       ID!
  name:     String!
  address:  String!
  telephone: Telephone!
  email:    Email!
}

"AccessAproval is a record representing a user approval for some access"
type AccessApproval {
  status:    SimpleApproval!
  approver:  User!
  reason:    String
  createdAt: Time!
}

"""
Approval request that can be approved or rejected
Used for creating stages and closing trades
"""
type ApproveReq {
  status:     Approval!
  reqActor:   TradeActor!
  reqBy:      User!
  reqAt:      Time!
  reqTx:  Hash
  reqReason:  String!
  approvedBy: User
  approvedAt: Time
  approvedTx: Hash
  rejectReason:   String
}

"Trade information"
type Trade {
  id:                ID!
  name:              String!
  description:       String!
  template:          TradeTemplate!
  buyer:             User!
  seller:            User!
  scAddr:            Hash!
  stages:            [TradeStage!]
  stageAddReqs:      [TradeStageAddReq!]
  closeReqs:         [ApproveReq!]!
  createdBy:         User!
  createdAt:         Time!
  tradeOffer:        TradeOffer
  moderating:        DoneStatus!
  actorWallet:       TradeActorWallet
}

"Trade stage add request"
type TradeStageAddReq {
  name:              String!
  description:       String!
  owner:             TradeActor!

  # ApproveReq fields
  status:       Approval!
  reqActor:     TradeActor!
  reqBy:        User!
  reqAt:        Time!
  reqReason:    String!
  approvedBy:   User
  approvedAt:   Time
  rejectReason: String
}

"Trade stage is a single step of a trade"
type TradeStage {
  name:        String!
  description: String!
  "index of addRequest of stage in trade"
  addReqIdx:   Int!
  owner:       TradeActor!
  expiresAt:   Time
  docs:        [TradeStageDoc!]!
  delReqs:     [ApproveReq!]!
  """
  Close requests. Can be closed only if stage is not deleted
  To compute the status of the stage you should use the following procedure.
  If ` + "`" + `closeReqs` + "`" + ` is empty then check then check the last element of delReqs.
  If it is approved then the stage is deleted.
  Else check the last element in ` + "`" + `closeReq` + "`" + `.
  """
  closeReqs:   [ApproveReq!]!
  moderator:   StageModerator
 }

"""
Trade stage document
Represents a single aggreement of a trade stage
Approval status is required for stage completeness
"""
type TradeStageDoc {
  doc:         Doc
  reqTx:       Hash
  status:      Approval!
  approvedBy:  User
  approvedAt:  Time
  approvedTx:  Hash
  expiresAt:   Time!
  rejectReason: String
}

"Document; Represents a single document saved to file"
type Doc {
  id:        ID!
  hash:      Hash!
  name:      String!
  note:      String!
  type:      String
  url:       String!
  createdBy: User!
  createdAt: Time!
}

"Trade template; Prefabricated blueprint for faster trade creation"
type TradeTemplate {
  id:          ID!
  name:        String!
  description: String!
  stages:      [TradeStageTemplate!]!
}

"Trade stage template; Prefabricated blueprint for faster stage creation"
type TradeStageTemplate {
  name:         String!
  description:  String!
  owner:        TradeActor!
}

"trade offer object"
type TradeOffer {
  id:        ID!
  price:     Float!
  isSell:    Boolean!
  priceType: OfferPriceType!
  currency:  Currency!
  createdBy: User!
  createdAt: Time!
  expiresAt: Time
  closedAt:  Time
  org:       Organization
  isAnonymous: Boolean!
  "commodity type"
  commodity: String!
  comType:   [String!]!
  quality:   String!
  origin:    String!
  incoterm:  Incoterm!
  marketLoc: String!
  "volumen - quantity"
  vol:       Int!
  "Shipment is a tuple representing: from-to"
  shipment:  [Time!]!
  note:      String!
  terms:     Doc
}

"StellarNet; stellar network infomation, we provide it to frontend"
type StellarNet {
  name:       String!
  url:        String!
  passphrase: String!
}

"Notification object"
type Notification {
  id:           ID!
  createdAt:    Time!
  triggeredBy:  User
  receiver:     [ID!]!
  type:         NotifType!
  dismissed:    [ID!]!
  entityID:     String!
  msg:          String!
  action:       Approval!
}

"TradeActorWallet; data about an actor in a trade"
type TradeActorWallet {
  pubKey:   String!
  keyPath:  String!
  walletID: String!
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_adminApproveUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.SimpleApproval
	if tmp, ok := rawArgs["status"]; ok {
		arg1, err = ec.unmarshalNSimpleApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐSimpleApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeCloseTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageAddTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageCloseTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_mkTradeStageDocTx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.Approval
	if tmp, ok := rawArgs["operationType"]; ok {
		arg1, err = ec.unmarshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["expiresAt"]; ok {
		arg2, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["expiresAt"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_notificationDismiss_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_organizationCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.OrgInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNOrgInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrgInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCloseReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewTradeInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNNewTradeInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewTradeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeOfferClose_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeOfferCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeOfferInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNTradeOfferInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOfferInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageAddReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewStageInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNNewStageInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewStageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["withApproval"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["withApproval"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageCloseReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReqApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReqReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDelReq_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDocApprove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageDocReject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStageDocPath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStageDocPath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDocPath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["signedTx"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["signedTx"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["reason"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_tradeStageSetExpireTime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TradeStagePath
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["expiresAt"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["expiresAt"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_userEmailChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNEmail2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userLogin_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserLoginInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUserLoginInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserLoginInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userPasswordChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChangePasswordInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNChangePasswordInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐChangePasswordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userProfileUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserProfileInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUserProfileInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserProfileInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userSignup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.NewUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalONewUserInput2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_notificationsTrade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_notifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["from"]; ok {
		arg0, err = ec.unmarshalNUint2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tradeOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_trade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AccessApproval_status(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SimpleApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSimpleApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐSimpleApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_approver(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AccessApproval().Approver(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_reason(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AccessApproval_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.AccessApproval) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AccessApproval",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _AdminUser_user(ctx context.Context, field graphql.CollectedField, obj *model.AdminUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AdminUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AdminUser_approvals(ctx context.Context, field graphql.CollectedField, obj *model.AdminUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AdminUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approvals, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AccessApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessApproval2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_status(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqActor(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqActor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqBy(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApproveReq().ReqBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqAt(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqTx(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_reqReason(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqReason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApproveReq().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_approvedTx(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApproveReq_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.ApproveReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ApproveReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthUser_id(ctx context.Context, field graphql.CollectedField, obj *model.AuthUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuthUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthUser_token(ctx context.Context, field graphql.CollectedField, obj *model.AuthUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuthUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_id(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_hash(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_name(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_note(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_type(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_url(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Doc().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Doc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Doc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userSignup(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userSignup_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserSignup(rctx, args["input"].(*model.NewUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userLogin(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userLogin_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserLogin(rctx, args["input"].(model.UserLoginInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAuthUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userPasswordChange(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userPasswordChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserPasswordChange(rctx, args["input"].(model.ChangePasswordInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userEmailChange(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userEmailChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserEmailChange(rctx, args["input"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_userProfileUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_userProfileUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserProfileUpdate(rctx, args["input"].(model.UserProfileInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_organizationCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_organizationCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OrganizationCreate(rctx, args["input"].(model.OrgInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrganization2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCreate(rctx, args["input"].(model.NewTradeInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTrade2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReq(rctx, args["input"].(model.NewStageInput), args["signedTx"].(string), args["withApproval"].(bool))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStageAddReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageAddReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReqApprove(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStage2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageAddReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageAddReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageAddReqReject(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReq(rctx, args["id"].(model.TradeStagePath), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReqApprove(rctx, args["id"].(model.TradeStagePath))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDelReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDelReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDelReqReject(rctx, args["id"].(model.TradeStagePath), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReq(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReqApprove(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageCloseReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageCloseReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageCloseReqReject(rctx, args["id"].(model.TradeStagePath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageSetExpireTime(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageSetExpireTime_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageSetExpireTime(rctx, args["id"].(model.TradeStagePath), args["expiresAt"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReq(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReq_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReq(rctx, args["id"].(string), args["reason"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReqApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReqApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReqApprove(rctx, args["id"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeCloseReqReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeCloseReqReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeCloseReqReject(rctx, args["id"].(string), args["reason"].(string), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDocApprove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDocApprove_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDocApprove(rctx, args["id"].(model.TradeStageDocPath), args["signedTx"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeStageDoc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageDoc2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeStageDocReject(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeStageDocReject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeStageDocReject(rctx, args["id"].(model.TradeStageDocPath), args["signedTx"].(string), args["reason"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeOfferCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeOfferCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeOfferCreate(rctx, args["input"].(model.TradeOfferInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_tradeOfferClose(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tradeOfferClose_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TradeOfferClose(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_notificationDismiss(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_notificationDismiss_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NotificationDismiss(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageDocTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageDocTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageDocTx(rctx, args["id"].(model.TradeStageDocPath), args["operationType"].(model.Approval), args["expiresAt"].(*time.Time))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageCloseTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageCloseTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageCloseTx(rctx, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeStageAddTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeStageAddTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeStageAddTx(rctx, args["id"].(model.TradeStagePath), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_mkTradeCloseTx(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_mkTradeCloseTx_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkTradeCloseTx(rctx, args["id"].(string), args["operationType"].(model.Approval))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_adminApproveUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_adminApproveUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminApproveUser(rctx, args["id"].(string), args["status"].(model.SimpleApproval), args["reason"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AccessApproval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAccessApproval2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_id(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_triggeredBy(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().TriggeredBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_receiver(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Receiver, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_type(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.NotifType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotifType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotifType(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_dismissed(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dismissed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_entityID(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_msg(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Notification_action(ctx context.Context, field graphql.CollectedField, obj *model.Notification) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Notification",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_address(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_telephone(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telephone, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTelephone2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_email(ctx context.Context, field graphql.CollectedField, obj *model.Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEmail2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_user_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_organizations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organizations(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adminUsers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminUsers(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AdminUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAdminUser2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAdminUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeTemplates(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeTemplates(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeTemplate2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trade(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_trade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trade(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTrade2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trades(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trades(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTrade2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeOffer(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_tradeOffer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeOffer(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tradeOffers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TradeOffers(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeOffer2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_notifications(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_notifications_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Notifications(rctx, args["from"].(uint))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotification2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_notificationsTrade(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_notificationsTrade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NotificationsTrade(rctx, args["id"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNotification2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_stellarNet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StellarNet(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StellarNet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStellarNet2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐStellarNet(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adminTrades(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminTrades(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTrade2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _StageModerator_user(ctx context.Context, field graphql.CollectedField, obj *model.StageModerator) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StageModerator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StageModerator().User(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _StageModerator_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.StageModerator) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StageModerator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_name(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_url(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StellarNet_passphrase(ctx context.Context, field graphql.CollectedField, obj *model.StellarNet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StellarNet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Passphrase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_id(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_name(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_description(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_template(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Template(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TradeTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeTemplate2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buyer(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Buyer(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_seller(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().Seller(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_scAddr(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().ScAddr(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_stages(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stages, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TradeStage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStage2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_stageAddReqs(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StageAddReqs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageAddReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeStageAddReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_closeReqs(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_tradeOffer(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().TradeOffer(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeOffer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeOffer2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_moderating(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moderating, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DoneStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDoneStatus2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoneStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_actorWallet(ctx context.Context, field graphql.CollectedField, obj *model.Trade) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trade().ActorWallet(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TradeActorWallet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTradeActorWallet2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActorWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_pubKey(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubKey, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_keyPath(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyPath, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeActorWallet_walletID(ctx context.Context, field graphql.CollectedField, obj *model.TradeActorWallet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeActorWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WalletID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_id(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_price(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_isSell(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSell, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_priceType(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriceType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.OfferPriceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOfferPriceType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOfferPriceType(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_currency(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Currency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_closedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_org(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().Org(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrganization2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_isAnonymous(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAnonymous, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_commodity(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commodity, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_comType(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ComType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_quality(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quality, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_origin(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_incoterm(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Incoterm, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Incoterm)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNIncoterm2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐIncoterm(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_marketLoc(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketLoc, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_vol(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vol, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_shipment(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shipment, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2ᚕtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_note(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeOffer_terms(ctx context.Context, field graphql.CollectedField, obj *model.TradeOffer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeOffer",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeOffer().Terms(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODoc2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_addReqIdx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddReqIdx, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_docs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Docs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageDoc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeStageDoc2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_delReqs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DelReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_closeReqs(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseReqs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApproveReq)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproveReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStage_moderator(ctx context.Context, field graphql.CollectedField, obj *model.TradeStage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moderator, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.StageModerator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStageModerator2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐStageModerator(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_status(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqActor(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqActor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageAddReq().ReqBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_reqReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqReason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageAddReq().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageAddReq_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageAddReq) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageAddReq",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_doc(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageDoc().Doc(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODoc2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_reqTx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReqTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_status(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Approval)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedBy(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradeStageDoc().ApprovedBy(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_approvedTx(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedTx, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageDoc_rejectReason(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageDoc) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageDoc",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeStageTemplate_owner(ctx context.Context, field graphql.CollectedField, obj *model.TradeStageTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeStageTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TradeActor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_id(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_name(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_description(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TradeTemplate_stages(ctx context.Context, field graphql.CollectedField, obj *model.TradeTemplate) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "TradeTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stages, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TradeStageTemplate)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTradeStageTemplate2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_firstName(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_lastName(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_emails(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Emails, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOEmail2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.UserRole)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUserRole2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) _User_avatar(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_orgMap(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().OrgMap(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UserOrgMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUserOrgMap2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMap(ctx, field.Selections, res)
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _User_biography(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Biography, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_pubKey(ctx context.Context, field graphql.CollectedField, obj *model.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().PubKey(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserOrgMap_org(ctx context.Context, field graphql.CollectedField, obj *model.UserOrgMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "UserOrgMap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Org, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _UserOrgMap_role(ctx context.Context, field graphql.CollectedField, obj *model.UserOrgMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "UserOrgMap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChangePasswordInput(ctx context.Context, v interface{}) (model.ChangePasswordInput, error) {
	var it model.ChangePasswordInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "oldPassword":
			var err error
			it.OldPassword, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "newPassword":
			var err error
			it.NewPassword, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewStageInput(ctx context.Context, v interface{}) (model.NewStageInput, error) {
	var it model.NewStageInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTradeInput(ctx context.Context, v interface{}) (model.NewTradeInput, error) {
	var it model.NewTradeInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "templateID":
			var err error
			it.TemplateID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sellerID":
			var err error
			it.SellerID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "buyerID":
			var err error
			it.BuyerID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeOfferID":
			var err error
			it.TradeOfferID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	var it model.NewUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "firstName":
			var err error
			it.FirstName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName":
			var err error
			it.LastName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatar":
			var err error
			it.Avatar, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicKey":
			var err error
			it.PublicKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biography":
			var err error
			it.Biography, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgID":
			var err error
			it.OrgID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgRole":
			var err error
			it.OrgRole, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrgInput(ctx context.Context, v interface{}) (model.OrgInput, error) {
	var it model.OrgInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "address":
			var err error
			it.Address, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "telephone":
			var err error
			it.Telephone, err = ec.unmarshalNTelephone2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeOfferInput(ctx context.Context, v interface{}) (model.TradeOfferInput, error) {
	var it model.TradeOfferInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "price":
			var err error
			it.Price, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "priceType":
			var err error
			it.PriceType, err = ec.unmarshalNOfferPriceType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOfferPriceType(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSell":
			var err error
			it.IsSell, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNCurrency2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAt":
			var err error
			it.ExpiresAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "commodity":
			var err error
			it.Commodity, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comType":
			var err error
			it.ComType, err = ec.unmarshalNString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "quality":
			var err error
			it.Quality, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgID":
			var err error
			it.OrgID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "origin":
			var err error
			it.Origin, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnonymous":
			var err error
			it.IsAnonymous, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "incoterm":
			var err error
			it.Incoterm, err = ec.unmarshalNIncoterm2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐIncoterm(ctx, v)
			if err != nil {
				return it, err
			}
		case "marketLoc":
			var err error
			it.MarketLoc, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vol":
			var err error
			it.Vol, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "shipment":
			var err error
			it.Shipment, err = ec.unmarshalNTime2ᚕtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "docID":
			var err error
			it.DocID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeStageDocPath(ctx context.Context, v interface{}) (model.TradeStageDocPath, error) {
	var it model.TradeStageDocPath
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageIdx":
			var err error
			it.StageIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageDocIdx":
			var err error
			it.StageDocIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageDocHash":
			var err error
			it.StageDocHash, err = ec.unmarshalNHash2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradeStagePath(ctx context.Context, v interface{}) (model.TradeStagePath, error) {
	var it model.TradeStagePath
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tid":
			var err error
			it.Tid, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stageIdx":
			var err error
			it.StageIdx, err = ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserLoginInput(ctx context.Context, v interface{}) (model.UserLoginInput, error) {
	var it model.UserLoginInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNEmail2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrgMapInput(ctx context.Context, v interface{}) (model.UserOrgMapInput, error) {
	var it model.UserOrgMapInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserProfileInput(ctx context.Context, v interface{}) (model.UserProfileInput, error) {
	var it model.UserProfileInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "firstName":
			var err error
			it.FirstName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName":
			var err error
			it.LastName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "orgMap":
			var err error
			it.OrgMap, err = ec.unmarshalOUserOrgMapInput2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMapInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "biography":
			var err error
			it.Biography, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accessApprovalImplementors = []string{"AccessApproval"}

func (ec *executionContext) _AccessApproval(ctx context.Context, sel ast.SelectionSet, obj *model.AccessApproval) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, accessApprovalImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessApproval")
		case "status":
			out.Values[i] = ec._AccessApproval_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approver":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AccessApproval_approver(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reason":
			out.Values[i] = ec._AccessApproval_reason(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._AccessApproval_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var adminUserImplementors = []string{"AdminUser"}

func (ec *executionContext) _AdminUser(ctx context.Context, sel ast.SelectionSet, obj *model.AdminUser) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, adminUserImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminUser")
		case "user":
			out.Values[i] = ec._AdminUser_user(ctx, field, obj)
		case "approvals":
			out.Values[i] = ec._AdminUser_approvals(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var approveReqImplementors = []string{"ApproveReq"}

func (ec *executionContext) _ApproveReq(ctx context.Context, sel ast.SelectionSet, obj *model.ApproveReq) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, approveReqImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApproveReq")
		case "status":
			out.Values[i] = ec._ApproveReq_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqActor":
			out.Values[i] = ec._ApproveReq_reqActor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApproveReq_reqBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reqAt":
			out.Values[i] = ec._ApproveReq_reqAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqTx":
			out.Values[i] = ec._ApproveReq_reqTx(ctx, field, obj)
		case "reqReason":
			out.Values[i] = ec._ApproveReq_reqReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApproveReq_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._ApproveReq_approvedAt(ctx, field, obj)
		case "approvedTx":
			out.Values[i] = ec._ApproveReq_approvedTx(ctx, field, obj)
		case "rejectReason":
			out.Values[i] = ec._ApproveReq_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *model.AuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, authUserImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "id":
			out.Values[i] = ec._AuthUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "token":
			out.Values[i] = ec._AuthUser_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var docImplementors = []string{"Doc"}

func (ec *executionContext) _Doc(ctx context.Context, sel ast.SelectionSet, obj *model.Doc) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, docImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Doc")
		case "id":
			out.Values[i] = ec._Doc_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hash":
			out.Values[i] = ec._Doc_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Doc_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "note":
			out.Values[i] = ec._Doc_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Doc_type(ctx, field, obj)
		case "url":
			out.Values[i] = ec._Doc_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Doc_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._Doc_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "userSignup":
			out.Values[i] = ec._Mutation_userSignup(ctx, field)
		case "userLogin":
			out.Values[i] = ec._Mutation_userLogin(ctx, field)
		case "userPasswordChange":
			out.Values[i] = ec._Mutation_userPasswordChange(ctx, field)
		case "userEmailChange":
			out.Values[i] = ec._Mutation_userEmailChange(ctx, field)
		case "userProfileUpdate":
			out.Values[i] = ec._Mutation_userProfileUpdate(ctx, field)
		case "organizationCreate":
			out.Values[i] = ec._Mutation_organizationCreate(ctx, field)
		case "tradeCreate":
			out.Values[i] = ec._Mutation_tradeCreate(ctx, field)
		case "tradeStageAddReq":
			out.Values[i] = ec._Mutation_tradeStageAddReq(ctx, field)
		case "tradeStageAddReqApprove":
			out.Values[i] = ec._Mutation_tradeStageAddReqApprove(ctx, field)
		case "tradeStageAddReqReject":
			out.Values[i] = ec._Mutation_tradeStageAddReqReject(ctx, field)
		case "tradeStageDelReq":
			out.Values[i] = ec._Mutation_tradeStageDelReq(ctx, field)
		case "tradeStageDelReqApprove":
			out.Values[i] = ec._Mutation_tradeStageDelReqApprove(ctx, field)
		case "tradeStageDelReqReject":
			out.Values[i] = ec._Mutation_tradeStageDelReqReject(ctx, field)
		case "tradeStageCloseReq":
			out.Values[i] = ec._Mutation_tradeStageCloseReq(ctx, field)
		case "tradeStageCloseReqApprove":
			out.Values[i] = ec._Mutation_tradeStageCloseReqApprove(ctx, field)
		case "tradeStageCloseReqReject":
			out.Values[i] = ec._Mutation_tradeStageCloseReqReject(ctx, field)
		case "tradeStageSetExpireTime":
			out.Values[i] = ec._Mutation_tradeStageSetExpireTime(ctx, field)
		case "tradeCloseReq":
			out.Values[i] = ec._Mutation_tradeCloseReq(ctx, field)
		case "tradeCloseReqApprove":
			out.Values[i] = ec._Mutation_tradeCloseReqApprove(ctx, field)
		case "tradeCloseReqReject":
			out.Values[i] = ec._Mutation_tradeCloseReqReject(ctx, field)
		case "tradeStageDocApprove":
			out.Values[i] = ec._Mutation_tradeStageDocApprove(ctx, field)
		case "tradeStageDocReject":
			out.Values[i] = ec._Mutation_tradeStageDocReject(ctx, field)
		case "tradeOfferCreate":
			out.Values[i] = ec._Mutation_tradeOfferCreate(ctx, field)
		case "tradeOfferClose":
			out.Values[i] = ec._Mutation_tradeOfferClose(ctx, field)
		case "notificationDismiss":
			out.Values[i] = ec._Mutation_notificationDismiss(ctx, field)
		case "mkTradeStageDocTx":
			out.Values[i] = ec._Mutation_mkTradeStageDocTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeStageCloseTx":
			out.Values[i] = ec._Mutation_mkTradeStageCloseTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeStageAddTx":
			out.Values[i] = ec._Mutation_mkTradeStageAddTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkTradeCloseTx":
			out.Values[i] = ec._Mutation_mkTradeCloseTx(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "adminApproveUser":
			out.Values[i] = ec._Mutation_adminApproveUser(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var notificationImplementors = []string{"Notification"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *model.Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, notificationImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "id":
			out.Values[i] = ec._Notification_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdAt":
			out.Values[i] = ec._Notification_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "triggeredBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_triggeredBy(ctx, field, obj)
				return res
			})
		case "receiver":
			out.Values[i] = ec._Notification_receiver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Notification_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dismissed":
			out.Values[i] = ec._Notification_dismissed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "entityID":
			out.Values[i] = ec._Notification_entityID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "msg":
			out.Values[i] = ec._Notification_msg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "action":
			out.Values[i] = ec._Notification_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "address":
			out.Values[i] = ec._Organization_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "telephone":
			out.Values[i] = ec._Organization_telephone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "email":
			out.Values[i] = ec._Organization_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "organizations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizations(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "adminUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminUsers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "tradeTemplates":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeTemplates(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "trade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trade(ctx, field)
				return res
			})
		case "trades":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trades(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "tradeOffer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeOffer(ctx, field)
				return res
			})
		case "tradeOffers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tradeOffers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "notifications":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notifications(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "notificationsTrade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notificationsTrade(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stellarNet":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stellarNet(ctx, field)
				return res
			})
		case "adminTrades":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminTrades(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var stageModeratorImplementors = []string{"StageModerator"}

func (ec *executionContext) _StageModerator(ctx context.Context, sel ast.SelectionSet, obj *model.StageModerator) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stageModeratorImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StageModerator")
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StageModerator_user(ctx, field, obj)
				return res
			})
		case "createdAt":
			out.Values[i] = ec._StageModerator_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var stellarNetImplementors = []string{"StellarNet"}

func (ec *executionContext) _StellarNet(ctx context.Context, sel ast.SelectionSet, obj *model.StellarNet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stellarNetImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StellarNet")
		case "name":
			out.Values[i] = ec._StellarNet_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._StellarNet_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "passphrase":
			out.Values[i] = ec._StellarNet_passphrase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeImplementors = []string{"Trade"}

func (ec *executionContext) _Trade(ctx context.Context, sel ast.SelectionSet, obj *model.Trade) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trade")
		case "id":
			out.Values[i] = ec._Trade_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Trade_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Trade_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "template":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_template(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "buyer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_buyer(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "seller":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_seller(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "scAddr":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_scAddr(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stages":
			out.Values[i] = ec._Trade_stages(ctx, field, obj)
		case "stageAddReqs":
			out.Values[i] = ec._Trade_stageAddReqs(ctx, field, obj)
		case "closeReqs":
			out.Values[i] = ec._Trade_closeReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._Trade_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tradeOffer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_tradeOffer(ctx, field, obj)
				return res
			})
		case "moderating":
			out.Values[i] = ec._Trade_moderating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "actorWallet":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trade_actorWallet(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeActorWalletImplementors = []string{"TradeActorWallet"}

func (ec *executionContext) _TradeActorWallet(ctx context.Context, sel ast.SelectionSet, obj *model.TradeActorWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeActorWalletImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeActorWallet")
		case "pubKey":
			out.Values[i] = ec._TradeActorWallet_pubKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "keyPath":
			out.Values[i] = ec._TradeActorWallet_keyPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "walletID":
			out.Values[i] = ec._TradeActorWallet_walletID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeOfferImplementors = []string{"TradeOffer"}

func (ec *executionContext) _TradeOffer(ctx context.Context, sel ast.SelectionSet, obj *model.TradeOffer) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeOfferImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeOffer")
		case "id":
			out.Values[i] = ec._TradeOffer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._TradeOffer_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isSell":
			out.Values[i] = ec._TradeOffer_isSell(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "priceType":
			out.Values[i] = ec._TradeOffer_priceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "currency":
			out.Values[i] = ec._TradeOffer_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_createdBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "createdAt":
			out.Values[i] = ec._TradeOffer_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expiresAt":
			out.Values[i] = ec._TradeOffer_expiresAt(ctx, field, obj)
		case "closedAt":
			out.Values[i] = ec._TradeOffer_closedAt(ctx, field, obj)
		case "org":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_org(ctx, field, obj)
				return res
			})
		case "isAnonymous":
			out.Values[i] = ec._TradeOffer_isAnonymous(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "commodity":
			out.Values[i] = ec._TradeOffer_commodity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "comType":
			out.Values[i] = ec._TradeOffer_comType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "quality":
			out.Values[i] = ec._TradeOffer_quality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "origin":
			out.Values[i] = ec._TradeOffer_origin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "incoterm":
			out.Values[i] = ec._TradeOffer_incoterm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "marketLoc":
			out.Values[i] = ec._TradeOffer_marketLoc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "vol":
			out.Values[i] = ec._TradeOffer_vol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "shipment":
			out.Values[i] = ec._TradeOffer_shipment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "note":
			out.Values[i] = ec._TradeOffer_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "terms":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeOffer_terms(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageImplementors = []string{"TradeStage"}

func (ec *executionContext) _TradeStage(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStage")
		case "name":
			out.Values[i] = ec._TradeStage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStage_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addReqIdx":
			out.Values[i] = ec._TradeStage_addReqIdx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStage_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expiresAt":
			out.Values[i] = ec._TradeStage_expiresAt(ctx, field, obj)
		case "docs":
			out.Values[i] = ec._TradeStage_docs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "delReqs":
			out.Values[i] = ec._TradeStage_delReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "closeReqs":
			out.Values[i] = ec._TradeStage_closeReqs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "moderator":
			out.Values[i] = ec._TradeStage_moderator(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageAddReqImplementors = []string{"TradeStageAddReq"}

func (ec *executionContext) _TradeStageAddReq(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageAddReq) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageAddReqImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageAddReq")
		case "name":
			out.Values[i] = ec._TradeStageAddReq_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStageAddReq_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStageAddReq_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._TradeStageAddReq_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqActor":
			out.Values[i] = ec._TradeStageAddReq_reqActor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageAddReq_reqBy(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "reqAt":
			out.Values[i] = ec._TradeStageAddReq_reqAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reqReason":
			out.Values[i] = ec._TradeStageAddReq_reqReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageAddReq_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._TradeStageAddReq_approvedAt(ctx, field, obj)
		case "rejectReason":
			out.Values[i] = ec._TradeStageAddReq_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageDocImplementors = []string{"TradeStageDoc"}

func (ec *executionContext) _TradeStageDoc(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageDoc) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageDocImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageDoc")
		case "doc":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageDoc_doc(ctx, field, obj)
				return res
			})
		case "reqTx":
			out.Values[i] = ec._TradeStageDoc_reqTx(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TradeStageDoc_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "approvedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradeStageDoc_approvedBy(ctx, field, obj)
				return res
			})
		case "approvedAt":
			out.Values[i] = ec._TradeStageDoc_approvedAt(ctx, field, obj)
		case "approvedTx":
			out.Values[i] = ec._TradeStageDoc_approvedTx(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._TradeStageDoc_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rejectReason":
			out.Values[i] = ec._TradeStageDoc_rejectReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeStageTemplateImplementors = []string{"TradeStageTemplate"}

func (ec *executionContext) _TradeStageTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.TradeStageTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeStageTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeStageTemplate")
		case "name":
			out.Values[i] = ec._TradeStageTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeStageTemplate_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "owner":
			out.Values[i] = ec._TradeStageTemplate_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var tradeTemplateImplementors = []string{"TradeTemplate"}

func (ec *executionContext) _TradeTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.TradeTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tradeTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradeTemplate")
		case "id":
			out.Values[i] = ec._TradeTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._TradeTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._TradeTemplate_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "stages":
			out.Values[i] = ec._TradeTemplate_stages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "firstName":
			out.Values[i] = ec._User_firstName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastName":
			out.Values[i] = ec._User_lastName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "emails":
			out.Values[i] = ec._User_emails(ctx, field, obj)
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "avatar":
			out.Values[i] = ec._User_avatar(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "orgMap":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_orgMap(ctx, field, obj)
				return res
			})
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "biography":
			out.Values[i] = ec._User_biography(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pubKey":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_pubKey(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var userOrgMapImplementors = []string{"UserOrgMap"}

func (ec *executionContext) _UserOrgMap(ctx context.Context, sel ast.SelectionSet, obj *model.UserOrgMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userOrgMapImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserOrgMap")
		case "org":
			out.Values[i] = ec._UserOrgMap_org(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "role":
			out.Values[i] = ec._UserOrgMap_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccessApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx context.Context, sel ast.SelectionSet, v model.AccessApproval) graphql.Marshaler {
	return ec._AccessApproval(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccessApproval2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx context.Context, sel ast.SelectionSet, v []model.AccessApproval) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccessApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAdminUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAdminUser(ctx context.Context, sel ast.SelectionSet, v model.AdminUser) graphql.Marshaler {
	return ec._AdminUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminUser2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAdminUser(ctx context.Context, sel ast.SelectionSet, v []model.AdminUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAdminUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx context.Context, v interface{}) (model.Approval, error) {
	var res model.Approval
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproval(ctx context.Context, sel ast.SelectionSet, v model.Approval) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApproveReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx context.Context, sel ast.SelectionSet, v model.ApproveReq) graphql.Marshaler {
	return ec._ApproveReq(ctx, sel, &v)
}

func (ec *executionContext) marshalNApproveReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx context.Context, sel ast.SelectionSet, v []model.ApproveReq) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApproveReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalNChangePasswordInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐChangePasswordInput(ctx context.Context, v interface{}) (model.ChangePasswordInput, error) {
	return ec.unmarshalInputChangePasswordInput(ctx, v)
}

func (ec *executionContext) unmarshalNCurrency2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐCurrency(ctx context.Context, v interface{}) (model.Currency, error) {
	var res model.Currency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNCurrency2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐCurrency(ctx context.Context, sel ast.SelectionSet, v model.Currency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDoneStatus2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoneStatus(ctx context.Context, v interface{}) (model.DoneStatus, error) {
	var res model.DoneStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNDoneStatus2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoneStatus(ctx context.Context, sel ast.SelectionSet, v model.DoneStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEmail2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalEmail(v)
}

func (ec *executionContext) marshalNEmail2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalEmail(v)
}

func (ec *executionContext) unmarshalNEmail2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNEmail2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNEmail2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNEmail2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalNHash2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalHash(v)
}

func (ec *executionContext) marshalNHash2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalHash(v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalNID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNIncoterm2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐIncoterm(ctx context.Context, v interface{}) (model.Incoterm, error) {
	var res model.Incoterm
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNIncoterm2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐIncoterm(ctx context.Context, sel ast.SelectionSet, v model.Incoterm) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalNNewStageInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewStageInput(ctx context.Context, v interface{}) (model.NewStageInput, error) {
	return ec.unmarshalInputNewStageInput(ctx, v)
}

func (ec *executionContext) unmarshalNNewTradeInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewTradeInput(ctx context.Context, v interface{}) (model.NewTradeInput, error) {
	return ec.unmarshalInputNewTradeInput(ctx, v)
}

func (ec *executionContext) unmarshalNNotifType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotifType(ctx context.Context, v interface{}) (model.NotifType, error) {
	var res model.NotifType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNNotifType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotifType(ctx context.Context, sel ast.SelectionSet, v model.NotifType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNNotification2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotification(ctx context.Context, sel ast.SelectionSet, v model.Notification) graphql.Marshaler {
	return ec._Notification(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotification2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotification(ctx context.Context, sel ast.SelectionSet, v []model.Notification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNOfferPriceType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOfferPriceType(ctx context.Context, v interface{}) (model.OfferPriceType, error) {
	var res model.OfferPriceType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNOfferPriceType2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOfferPriceType(ctx context.Context, sel ast.SelectionSet, v model.OfferPriceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNOrgInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrgInput(ctx context.Context, v interface{}) (model.OrgInput, error) {
	return ec.unmarshalInputOrgInput(ctx, v)
}

func (ec *executionContext) marshalNOrganization2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v []model.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNSimpleApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐSimpleApproval(ctx context.Context, v interface{}) (model.SimpleApproval, error) {
	var res model.SimpleApproval
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSimpleApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐSimpleApproval(ctx context.Context, sel ast.SelectionSet, v model.SimpleApproval) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.marshalNString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalNTelephone2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalTelephone(v)
}

func (ec *executionContext) marshalNTelephone2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalTelephone(v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return model.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	if v.IsZero() {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return model.MarshalTime(v)
}

func (ec *executionContext) unmarshalNTime2ᚕtimeᚐTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTime2ᚕtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTrade2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx context.Context, sel ast.SelectionSet, v model.Trade) graphql.Marshaler {
	return ec._Trade(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrade2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx context.Context, sel ast.SelectionSet, v []model.Trade) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrade2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx context.Context, v interface{}) (model.TradeActor, error) {
	var res model.TradeActor
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNTradeActor2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActor(ctx context.Context, sel ast.SelectionSet, v model.TradeActor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTradeOffer2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx context.Context, sel ast.SelectionSet, v model.TradeOffer) graphql.Marshaler {
	return ec._TradeOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeOffer2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx context.Context, sel ast.SelectionSet, v []model.TradeOffer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeOffer2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeOfferInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOfferInput(ctx context.Context, v interface{}) (model.TradeOfferInput, error) {
	return ec.unmarshalInputTradeOfferInput(ctx, v)
}

func (ec *executionContext) marshalNTradeStage2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx context.Context, sel ast.SelectionSet, v model.TradeStage) graphql.Marshaler {
	return ec._TradeStage(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageAddReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v model.TradeStageAddReq) graphql.Marshaler {
	return ec._TradeStageAddReq(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageDoc2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v model.TradeStageDoc) graphql.Marshaler {
	return ec._TradeStageDoc(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageDoc2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageDoc) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageDoc2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNTradeStageDocPath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDocPath(ctx context.Context, v interface{}) (model.TradeStageDocPath, error) {
	return ec.unmarshalInputTradeStageDocPath(ctx, v)
}

func (ec *executionContext) unmarshalNTradeStagePath2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStagePath(ctx context.Context, v interface{}) (model.TradeStagePath, error) {
	return ec.unmarshalInputTradeStagePath(ctx, v)
}

func (ec *executionContext) marshalNTradeStageTemplate2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageTemplate(ctx context.Context, sel ast.SelectionSet, v model.TradeStageTemplate) graphql.Marshaler {
	return ec._TradeStageTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeStageTemplate2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageTemplate(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageTemplate2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTradeTemplate2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx context.Context, sel ast.SelectionSet, v model.TradeTemplate) graphql.Marshaler {
	return ec._TradeTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNTradeTemplate2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx context.Context, sel ast.SelectionSet, v []model.TradeTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeTemplate2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTradeTemplate2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeTemplate(ctx context.Context, sel ast.SelectionSet, v *model.TradeTemplate) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TradeTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint2uint(ctx context.Context, v interface{}) (uint, error) {
	return model.UnmarshalUint(v)
}

func (ec *executionContext) marshalNUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	return model.MarshalUint(v)
}

func (ec *executionContext) marshalNUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v []model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserLoginInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserLoginInput(ctx context.Context, v interface{}) (model.UserLoginInput, error) {
	return ec.unmarshalInputUserLoginInput(ctx, v)
}

func (ec *executionContext) marshalNUserOrgMap2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMap(ctx context.Context, sel ast.SelectionSet, v model.UserOrgMap) graphql.Marshaler {
	return ec._UserOrgMap(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUserOrgMapInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMapInput(ctx context.Context, v interface{}) (model.UserOrgMapInput, error) {
	return ec.unmarshalInputUserOrgMapInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserProfileInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserProfileInput(ctx context.Context, v interface{}) (model.UserProfileInput, error) {
	return ec.unmarshalInputUserProfileInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserRole2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx context.Context, v interface{}) (model.UserRole, error) {
	var res model.UserRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUserRole2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserRole2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx context.Context, v interface{}) ([]model.UserRole, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]model.UserRole, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserRole2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserRole2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx context.Context, sel ast.SelectionSet, v []model.UserRole) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserRole2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Directive2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalOAccessApproval2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx context.Context, sel ast.SelectionSet, v model.AccessApproval) graphql.Marshaler {
	return ec._AccessApproval(ctx, sel, &v)
}

func (ec *executionContext) marshalOAccessApproval2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAccessApproval(ctx context.Context, sel ast.SelectionSet, v *model.AccessApproval) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccessApproval(ctx, sel, v)
}

func (ec *executionContext) marshalOApproveReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx context.Context, sel ast.SelectionSet, v model.ApproveReq) graphql.Marshaler {
	return ec._ApproveReq(ctx, sel, &v)
}

func (ec *executionContext) marshalOApproveReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐApproveReq(ctx context.Context, sel ast.SelectionSet, v *model.ApproveReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApproveReq(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAuthUser(ctx context.Context, sel ast.SelectionSet, v model.AuthUser) graphql.Marshaler {
	return ec._AuthUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAuthUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐAuthUser(ctx context.Context, sel ast.SelectionSet, v *model.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalODoc2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoc(ctx context.Context, sel ast.SelectionSet, v model.Doc) graphql.Marshaler {
	return ec._Doc(ctx, sel, &v)
}

func (ec *executionContext) marshalODoc2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐDoc(ctx context.Context, sel ast.SelectionSet, v *model.Doc) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Doc(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmail2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNEmail2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEmail2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNEmail2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOHash2string(ctx context.Context, v interface{}) (string, error) {
	return model.UnmarshalHash(v)
}

func (ec *executionContext) marshalOHash2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return model.MarshalHash(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalONewUserInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	return ec.unmarshalInputNewUserInput(ctx, v)
}

func (ec *executionContext) unmarshalONewUserInput2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewUserInput(ctx context.Context, v interface{}) (*model.NewUserInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalONewUserInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐNewUserInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOOrganization2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalOOrganization2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalOStageModerator2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐStageModerator(ctx context.Context, sel ast.SelectionSet, v model.StageModerator) graphql.Marshaler {
	return ec._StageModerator(ctx, sel, &v)
}

func (ec *executionContext) marshalOStellarNet2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐStellarNet(ctx context.Context, sel ast.SelectionSet, v model.StellarNet) graphql.Marshaler {
	return ec._StellarNet(ctx, sel, &v)
}

func (ec *executionContext) marshalOStellarNet2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐStellarNet(ctx context.Context, sel ast.SelectionSet, v *model.StellarNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StellarNet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return model.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	if v.IsZero() {
		return graphql.Null
	}
	return model.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) marshalOTrade2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx context.Context, sel ast.SelectionSet, v model.Trade) graphql.Marshaler {
	return ec._Trade(ctx, sel, &v)
}

func (ec *executionContext) marshalOTrade2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTrade(ctx context.Context, sel ast.SelectionSet, v *model.Trade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Trade(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeActorWallet2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActorWallet(ctx context.Context, sel ast.SelectionSet, v model.TradeActorWallet) graphql.Marshaler {
	return ec._TradeActorWallet(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeActorWallet2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeActorWallet(ctx context.Context, sel ast.SelectionSet, v *model.TradeActorWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeActorWallet(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeOffer2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx context.Context, sel ast.SelectionSet, v model.TradeOffer) graphql.Marshaler {
	return ec._TradeOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeOffer2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeOffer(ctx context.Context, sel ast.SelectionSet, v *model.TradeOffer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeOffer(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStage2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx context.Context, sel ast.SelectionSet, v model.TradeStage) graphql.Marshaler {
	return ec._TradeStage(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStage2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx context.Context, sel ast.SelectionSet, v []model.TradeStage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStage2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTradeStage2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStage(ctx context.Context, sel ast.SelectionSet, v *model.TradeStage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStage(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStageAddReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v model.TradeStageAddReq) graphql.Marshaler {
	return ec._TradeStageAddReq(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStageAddReq2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v []model.TradeStageAddReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradeStageAddReq2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTradeStageAddReq2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageAddReq(ctx context.Context, sel ast.SelectionSet, v *model.TradeStageAddReq) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStageAddReq(ctx, sel, v)
}

func (ec *executionContext) marshalOTradeStageDoc2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v model.TradeStageDoc) graphql.Marshaler {
	return ec._TradeStageDoc(ctx, sel, &v)
}

func (ec *executionContext) marshalOTradeStageDoc2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐTradeStageDoc(ctx context.Context, sel ast.SelectionSet, v *model.TradeStageDoc) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TradeStageDoc(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserOrgMap2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMap(ctx context.Context, sel ast.SelectionSet, v []model.UserOrgMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserOrgMap2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOUserOrgMapInput2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMapInput(ctx context.Context, v interface{}) ([]model.UserOrgMapInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]model.UserOrgMapInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserOrgMapInput2bitbucketᚗorgᚋcerealiaᚋappsᚋgoᚑlibᚋmodelᚐUserOrgMapInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2bitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖbitbucketᚗorgᚋcerealiaᚋappsᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
